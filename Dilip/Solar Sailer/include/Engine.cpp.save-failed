/**
*Greeting!!!
*You are always allowed to edit the stuffs here to make things work for you as long as you don't blame me for any kind of misuse
*
*Please note:
* a)GL/glut.h file required for creating the window
* b)Copy "stb_image" folder also from near somewhere as it uses this for image handling
* c)GL-Math library is used for calculations so you need to have "glm" library at your IDE include folder
*   or if you have somewhere else, you can change that by editing the include line below
* d)GLEW is required to have in your IDE include as GL/glew.h
* e)Why are you still reading? Start making stuffs you always imagined!! Good Luck!!!
*/
#define GLEW_STATIC

#include <GL/glew.h>
#include <GL/glut.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <bits/stdc++.h>
#include "stb_image/stb_image.h"
#include <string.h>

#define ASSERT(x) if(!x)exit(0)

#define GLCall(x)\
        GLErrorDetect::GLClearErrors();\
        x;\
        ASSERT(GLErrorDetect::GLLogError(#x, __FILE__, __LINE__))

/**
Name space used just for handling OpenGL errors
*/
namespace GLErrorDetect{
    static void GLClearErrors(){
        while(glGetError() != GL_NO_ERROR);
    }

    static bool GLLogError(const char* function, const char *file, int line){
        while(GLenum error = glGetError()){
            std::cout << "GL Error Code : " << error << std::endl;
            std::cout << "Error in function :" << function <<  std::endl;
            std::cout << "At location :" << file << std::endl;
            std::cout << "At line number :" << line <<std::endl;
            return false;
        }
        return true;
    }

}

/**
Name space containing functions to be used generally while creating windows and etc
*/
namespace Window{

    /**
    *Pass the arguments exactly from main
    *address of must be passed
    */
    static void createGlutWindow(int &argc, char *argv[],char* Title,glm::vec2 windowPosition,glm::vec2 windowSize){
        glutInit(&argc, argv);
        glutInitWindowSize(windowSize.x,windowSize.y);
        glutInitWindowPosition(windowPosition.x,windowPosition.y);
        glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_MULTISAMPLE);
        glutCreateWindow(Title);
    }

    /**
    *Does not draw non-visible faces
    *Call it after window is created
    */
    static void enableBackfaceCulling(){
        glEnable(GL_CULL_FACE);
        glCullFace(GL_BACK);
    }

    /**
    *Disable culling enabled
    *Call it after window is created
    */
    static void disableBackfaceCulling(){
        glDisable(GL_CULL_FACE);
    }

    /**
    *Enables the clipping of non-visible surfaces
    *i.e occlusion culling
    *Call it after window is created
    */
    static void enableDepthTest(){
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);
    }

    /**
    *Initialize and Checks if GLEW functions are supported
    *Prints error in console if error exists
    *Prints the GLEW version currently using
    */
    static void initializeGLEW(bool displayStatus = true){
        GLenum err = glewInit();
        if (GLEW_OK != err){
            fprintf(stderr, "Error: %s\n", glewGetErrorString(err));
        }
        if(displayStatus){
            fprintf(stdout, "Status: Using GLEW %s\n", glewGetString(GLEW_VERSION));
        }
    }

    /**
    *Enables alpha blending
    */
    static void enableAlphaBlending(){
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    }

    /**
    *Enables additive blending
    */
    static void enableAdditiveBlending(){
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE);
    }

    /**
    *Disables any blending
    */
    static void disableBlending(){
        glDisable(GL_BLEND);
    }

    /**
    *Enables CLIP_DISTANCE0
    */
    static void enableClipDistance0(){
        glEnable(GL_CLIP_DISTANCE0);
    }
};

/**
Object orienting the OpenGL data types
*/
namespace OpenGL{
    /**
    *Structure of both shaders to be loaded into same program
    */
    struct shaderProgramSource{
        std::string vertexShader;
        std::string fragmentShader;
    };

    /**
    *Used for making pseudo hash map storing the name and location
    */
    struct uniformLocation{
        std::string name;
        int location;
    };

    /**
    *Object oriented version of OpenGL shader type
    */
    class Shader{
    private:
    private:
        unsigned int shader;
        std::string m_filePath;
        std::vector<uniformLocation> locations;

        /**
        *Reads shader from file
        */
        static shaderProgramSource parseShader(const std::string& filePath){
            enum {
                NONE = -1, VERTEX_SHADER = 0, FRAGMENT_SHADER = 1
            };

            std::string line;
            std::stringstream ss[2];
            std::ifstream stream(filePath.c_str());
            int type = NONE;

            if(stream == NULL){
                std::cout << "Cannot Read File" << std::endl;
            }

            while(getline(stream, line) != NULL){
                //If shader definition is found
                if(line.find("#shader") != std::string::npos){
                    //If that is vertex shader
                    if(line.find("vertex") != std::string::npos)
                        type = VERTEX_SHADER;
                    //If that is fragment shader
                    else if(line.find("fragment") != std::string::npos)
                        type = FRAGMENT_SHADER;
                }
                else{
                    ss[type] << line << "\n";
                }
            }
            return {ss[0].str(), ss[1].str()};
        }

        /**
        *Creates the shader of specified type and compiles
        */
        static unsigned int compileShader(GLenum type, std::string& source){
            unsigned int id = glCreateShader(type);
            const char* src = source.c_str();
            glShaderSource(id, 1, &src, NULL);
            glCompileShader(id);

            //Checking the compilation and error handling
            int result;
            glGetShaderiv(id, GL_COMPILE_STATUS, &result);
            if(result == GL_FALSE){
                int msgLength;
                glGetShaderiv(id, GL_INFO_LOG_LENGTH, &msgLength);
                char* message = new char[msgLength];//(char*)alloca(msgLength*sizeof(char));

                glGetShaderInfoLog(id, msgLength, &msgLength, message);
                std::cout << "Failed to compile " <<
                    ((type==GL_VERTEX_SHADER)?"vertex":"fragment") << " shader" << std::endl;
                std::cout << message;
                glDeleteShader(id);
                return 0;
            }
            return id;
        }

        /**
        *Creates shader program and returns its id
        */
        static unsigned int createShader(std::string& vertexShader, std::string& fragmentShader){
            //Create program and shader
            unsigned int program = glCreateProgram();
            unsigned int vs = compileShader(GL_VERTEX_SHADER, vertexShader);
            unsigned int fs = compileShader(GL_FRAGMENT_SHADER, fragmentShader);

            //Attach created and compiled shader to program
            glAttachShader(program, vs);
            glAttachShader(program, fs);

            //Link and validate the program
            glLinkProgram(program);
            glValidateProgram(program);

            //Delete the shader after we have attached
            glDeleteShader(vs);
            glDeleteShader(fs);

            return program;
        }

        /**
        *Finds the location of uniform in loaded shader file
        */
        int findUniformLocation(std::string uniformName){

            for(unsigned int i=0; i<locations.size(); i++){
                if(locations[i].name == uniformName)
                    return locations[i].location;
            }

            int location = glGetUniformLocation(shader, uniformName.c_str());
            locations.push_back({uniformName, location});

            if(location == -1)
                std::cout << "Warning : " << "uniform '" << uniformName <<  "' doesn't exist" <<std::endl;

            return location;
        }

    public:
        /**
        *Loads the shader from specified file
        */
        void loadShader(std::string shaderFile){
            m_filePath = shaderFile;
            shaderProgramSource shaderProgram = parseShader(shaderFile);
            shader = createShader(shaderProgram.vertexShader, shaderProgram.fragmentShader);
        }

        /**
        *Uses the loaded created shader
        */
        void bind() const{
            GLCall(glUseProgram(shader));
        }

        /**
        *Unbinds shader
        */
        void unbind() const{
            GLCall(glUseProgram(0));
        }

        /**
        *Deletes the used and created shader
        */
        void deleteShader(){
            locations.clear();
            GLCall(glDeleteShader(shader));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniform4f(std::string name, float data[]){
            GLCall(glUniform4f(findUniformLocation(name), data[0], data[1], data[2], data[3]));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniform4f(std::string name, glm::vec4 data){
            GLCall(glUniform4f(findUniformLocation(name), data.x, data.y, data.z, data.w));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniform3f(std::string name, float data[]){
            GLCall(glUniform3f(findUniformLocation(name), data[0], data[1], data[2]));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniform2f(std::string name, float data[]){
            GLCall(glUniform2f(findUniformLocation(name), data[0], data[1]));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniform1iv(std::string name, int data[]){
            GLCall(glUniform1iv(findUniformLocation(name), 2, data));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniform1f(std::string name, float data){
            GLCall(glUniform1f(findUniformLocation(name), data));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniform1fv(std::string name, float* data, unsigned int count){
            GLCall(glUniform1fv(findUniformLocation(name), count, data));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniform1i(std::string name, int data){
            GLCall(glUniform1i(findUniformLocation(name), data));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        */
        void addUniformMat4f(std::string name, glm::mat4& data){
            GLCall(glUniformMatrix4fv(findUniformLocation(name), 1, GL_FALSE, &data[0][0]));
        }

        /**
        *Adds the uniform data to the shader used
        *Use this after shader is used
        *@param name = name in shader
        *@param data = pointer to first element of first matrix
        *@param elementCount = no. of matrices to be loaded
        */
        void addUniformMat4fv(std::string name, float* data, unsigned int elementCount){
            GLCall(glUniformMatrix4fv(findUniformLocation(name), elementCount, GL_FALSE, data));
        }

        /**
        *@return location of attribute in shader
        */
        unsigned int getAttriblocation(const std::string& name){
            int location = glGetAttribLocation(shader, name.c_str());
            if(location == -1){
                std::cout << "Cannot find attribute" << std::endl;
                return 0;
            }
            return (unsigned int)location;
        }
    };

    /**
    *Object oriented version of OpenGL texture type
    */
    class Texture{
    private:
        unsigned int m_rendererID;
        std::string m_filePath;
        unsigned char* m_localBuffer;
        int m_height, m_width, m_BPP;

    public:
        /**
        *To load texture from file path specified
        */
        void loadTexture(std::string filePath, bool useMipmap = true, float levelOfDetails=-1.5f, float an = 4.0){
            m_rendererID = 0;
            m_filePath = filePath;
            m_localBuffer = NULL;
            m_height = 0;
            m_width = 0;
            m_BPP = 0;

            //Storing the pixel data in local buffer
            stbi_set_flip_vertically_on_load(1);
            m_localBuffer = stbi_load(filePath.c_str(), &m_width, &m_height, &m_BPP, 4);

            //Generate and bind texture
            GLCall(glGenTextures(1, &m_rendererID));
            GLCall(glBindTexture(GL_TEXTURE_2D, m_rendererID));

            //Specifying the texture properties
            if(useMipmap){
                float aniso;
                GLCall(glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &aniso));
                an = an>aniso?aniso:an;
                GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR));
                GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, levelOfDetails));
                GLCall(glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, an));
            }
            else{
                GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
            }

            GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
            GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
            GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));

            //Feeding the data to texture
            if(useMipmap){
                GLCall(gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, m_width, m_height, GL_RGBA, GL_UNSIGNED_BYTE, m_localBuffer));
            }
            else{
                GLCall(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, m_width, m_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, m_localBuffer));
            }

            //Unbinding the texture after data is feeded
            GLCall(glBindTexture(GL_TEXTURE_2D, 0));

            //Freeing the memory from local buffer
            if(m_localBuffer){
                stbi_image_free(m_localBuffer);
            }
        }

        /**
        *@param id of created texture
        *Used if the texture is already created in another location
        */
        void loadCreatedTexture(unsigned int id){
            m_rendererID = id;
        }

        /**
        *@return id of the texture object
        */
        unsigned int getID(){
            return m_rendererID;
        }

        /**
        *Binding the texture at @param slot (default=0 slot)
        */
        void bind(unsigned int slot = 0) const{
            GLCall(glActiveTexture(GL_TEXTURE0 + slot));
            GLCall(glBindTexture(GL_TEXTURE_2D, m_rendererID));
        }

        /**
        *Unbind the texture from currently bounded slot
        */
        void unbind() const{
            GLCall(glBindTexture(GL_TEXTURE_2D, m_rendererID));
        }

        /**
        *Getter for texture width
        */
        inline int getWidth(){
            return m_width;
        }

        /**
        *Getter for texture height
        */
        inline int getHeight(){
            return m_height;
        }

        /**
        *Delete the texture from memory
        */
        void deleteTexture(){
            GLCall(glDeleteTextures(1, &m_rendererID));
        }
    };

    /**
    *Object orienting the vertex buffer where data are stored
    */
    class VertexBuffer{
    private:
        unsigned int m_renderID;

    public:
        /**
        *Null constructor
        */
        VertexBuffer(){
        }

        /**
        *Creates the vertex buffer and binds the data
        */
        void loadData(const void* data, unsigned int dataSize){
            //Generate a array buffer
            GLCall(glGenBuffers(1, &m_renderID));

            //Storing the data into the buffer
            GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_renderID));
            GLCall(glBufferData(GL_ARRAY_BUFFER, dataSize, data, GL_STATIC_DRAW));
        }

        /**
        *Creates the vertex buffer but only allocates memory without filling it
        *Also binds automatically
        */
        void allocateDynamically(unsigned int dataSize){
            //Generate a array buffer
            GLCall(glGenBuffers(1, &m_renderID));

            //Storing the data into the buffer
            GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_renderID));
            GLCall(glBufferData(GL_ARRAY_BUFFER, dataSize, NULL, GL_DYNAMIC_DRAW));
        }

        /**
        *Adds data to allocated memory
        */
        void feedDatatoAllocated(const void* data, unsigned int dataSize){
            bind();
            GLCall(glBufferSubData(GL_ARRAY_BUFFER, 0, dataSize, data));
        }

        /**
        *Creates the vertex buffer and binds the data
        */
        VertexBuffer(const void* data, unsigned int dataSize){
            loadData(data,dataSize);
        }

        /**
        *Binds the vertex buffer
        */
        void bind() const{
            GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_renderID));
        }

        /**
        *Unbinds the vertex buffer
        */
        void unbind() const{
            GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
        }

        /**
        *Deleting the buffer contents and freeing the memory
        */
        void deleteVertexBuffer(){
            GLCall(glDeleteBuffers(1, &m_renderID));
        }
    };

    /**
    *Object orienting the index buffer where indices of vertex buffer is stored
    */
    class IndexBuffer{
    private:
        unsigned int m_renderID;
        unsigned int m_count;

    public:
        /**
        *Null constructor
        */
        IndexBuffer(){
        }

        /**
        *Creates the index buffer and binds the data
        */
        void loadData(const unsigned int* data, unsigned int count){
            m_count = count;
            //Generate a index buffer
            GLCall(glGenBuffers(1, &m_renderID));

            //Storing the data into the buffer
            GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_renderID));
            GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, count*sizeof(unsigned int), data, GL_STATIC_DRAW));
        }

        /**
        *Creates the index buffer and binds the data
        */
        IndexBuffer(const unsigned int* data, unsigned int count):m_count(count){
            loadData(data, count);
        }

        /**
        *Binds the index buffer
        */
        void bind() const{
            GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_renderID));
        }

        /**
        *Unbinds the index buffer
        */
        void unbind() const{
            GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));
        }

        /**
        *@return count of indices
        */
        unsigned int getCount(){
            return m_count;
        }

        /**
        *Deleting the index buffer contents and freeing the memory
        */
        void deleteIndexBuffer(){
            GLCall(glDeleteBuffers(1, &m_renderID));
        }
    };

    /**
    *Object orienting the frame buffer data type
    */
    class FrameBuffer{
    private:
        unsigned int m_rendererID;

    public:
        /**
        *Must be called initially when frame buffer is to be initialized
        */
        void generateFrameBuffer(bool colorAttachMent = true){
            GLCall(glGenFramebuffers(1, &m_rendererID));
            GLCall(glBindFramebuffer(GL_FRAMEBUFFER, m_rendererID));
            if(colorAttachMent) {GLCall(glDrawBuffer(GL_COLOR_ATTACHMENT0));}
            else                {GLCall(glDrawBuffer(GL_NONE));}
            GLCall(glBindFramebuffer(GL_FRAMEBUFFER, 0));
        }

        /**
        *@return the texture id of attached color texture
        *Must be linked with another texture to use
        *frame buffer must be generated first to use
        */
        unsigned int AttachColorTexture(int width, int height){
            unsigned int m_rendererID;
            GLCall(glGenTextures(1, &m_rendererID));
            GLCall(glBindTexture(GL_TEXTURE_2D, m_rendererID));
            GLCall(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL));
            GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
            GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
            GLCall(glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_rendererID, 0));
            return m_rendererID;
        }

        /**
        *@return the texture id of attached depth texture
        *Must be linked with another texture to use
        *frame buffer must be generated first to use
        */
        unsigned int AttachDepthTexture(int width, int height){
            unsigned int m_rendererID;
            GLCall(glGenTextures(1, &m_rendererID));
            GLCall(glBindTexture(GL_TEXTURE_2D, m_rendererID));

            GLCall(glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, NULL));
            GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
            GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
            GLCall(glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, m_rendererID, 0));
            return m_rendererID;
        }

        /**
        *Binds the frame buffer object
        *But first we need to bind the texture attached or to be used
        */
        void bind(int width, int height){
            GLCall(glBindFramebuffer(GL_FRAMEBUFFER, m_rendererID));
            GLCall(glViewport(0, 0, width, height));
        }

        /**
        *Unbinds the current frame buffer and binds default frame buffer with specified view-port
        */
        void unbind(int screenWidth, int screenHeight){
            GLCall(glBindFramebuffer(GL_FRAMEBUFFER, 0));
            GLCall(glViewport(0, 0, screenWidth, screenHeight));
        }

        /**
        *Deleting the frame buffer and freeing the memory
        */
        void deleteBuffer(){
            glDeleteFramebuffers(1, &m_rendererID);
        }
    };

    /**
    *Used to make vertex buffer layout for storing the information of each vertex buffer
    */
    struct VertexBufferElement{
        unsigned int type;
        unsigned int count;
        unsigned char normalized;

        /**
        *@return size of type in byte of @param
        */
        static unsigned int getSizeOfType(unsigned int type){
            switch(type){
                case GL_FLOAT:
                    return sizeof(float);
                case GL_UNSIGNED_INT:
                    return sizeof(unsigned int);
                case GL_UNSIGNED_BYTE:
                    return sizeof(unsigned char);
            }
            return 0;
        }
    };

    /**
    *Used to make vertex array for storing the information of vertex buffers
    *Used to specify the layout of vertex buffer in vertex array
    */
    class VertexBufferLayout{
    private:
        int m_stride;
        std::vector<VertexBufferElement> m_elements;
    public:
        /**
        *Initializer/constructor
        */
        VertexBufferLayout():m_stride(0){
        }

        /**
        *Adds the layout for float with count parameter
        */
        void pushFloat(unsigned int count){
            m_elements.push_back({GL_FLOAT, count, GL_FALSE});
            m_stride += count * VertexBufferElement::getSizeOfType(GL_FLOAT);
        }

        /**
        *Adds the layout for unsigned int with count parameter
        */
        void pushUnsignedInt(unsigned int count){
            m_elements.push_back({GL_UNSIGNED_INT, count, GL_FALSE});
            m_stride += count * VertexBufferElement::getSizeOfType(GL_UNSIGNED_INT);
        }

        /**
        *Adds the layout for unsigned byte with count parameter
        */
        void pushUnsignedChar(unsigned int count){
            m_elements.push_back({GL_UNSIGNED_BYTE, count, GL_TRUE});
            m_stride += count * VertexBufferElement::getSizeOfType(GL_UNSIGNED_BYTE);
        }

        /**
        *@return the VertexBufferElement stored
        */
        std::vector<VertexBufferElement> getBufferElement(){
            return m_elements;
        }

        /**
        *@return the stride calculated
        */
        int getStride(){
            return m_stride;
        }
    };

    /**
    *Making object oriented version of vertex array
    */
    class VertexArray{
    private:
        unsigned int m_rendererID;
    public:
        /**
        *Generates the vertexArray
        */
        void generateVertexArray(){
            GLCall(glGenVertexArrays(1, &m_rendererID));
        }

        /**
        *Binds the generated vertex array
        */
        void bind() const{
            GLCall(glBindVertexArray(m_rendererID));
        }

        /**
        *Unbinds the generated vertex array
        */
        void unbind() const{
            GLCall(glBindVertexArray(0));
        }

        /**
        *Stores vertex buffer and layout to the vertex array
        *Vertex array must be generated first
        */
        void addBuffer(VertexBuffer& vb,VertexBufferLayout& layout){
            bind();
            vb.bind();
            std::vector<VertexBufferElement> elements = layout.getBufferElement();
            unsigned int offset = 0;

            for(unsigned int i=0; i < elements.size(); i++){
                VertexBufferElement element = elements[i];
                //Specifying the layout
                GLCall(glEnableVertexAttribArray(i));
                if((element.type==GL_INT)||
                   (element.type==GL_UNSIGNED_INT)||
                   (element.type==GL_BYTE)||
                   (element.type==GL_UNSIGNED_BYTE)||
                   (element.type==GL_SHORT)||
                   (element.type==GL_UNSIGNED_SHORT)){
                    GLCall(glVertexAttribIPointer(i, element.count, element.type,
                                                  layout.getStride(), (const void*)offset));
                }
                else{
                    GLCall(glVertexAttribPointer(i, element.count, element.type,
                                                 element.normalized, layout.getStride(), (const void*)offset));
                }
                offset += element.count * VertexBufferElement::getSizeOfType(element.type);
            }
        }

        /**
        *Deleting the vertex array and freeing the memory
        */
        void deleteVertexArray(){
            GLCall(glDeleteVertexArrays(1, &m_rendererID));
        }
    };

    /**
    *Object version of cube map texture
    */
    class CubeMap{
    private:
        unsigned int m_rendererID;

    public:
        /**
        *@param file path vector contains the list of 6 textures of 6 faces of cube map
        *Order follows as positive x, negative x, positive y, negative y, positive z, negative z
        */
        void loadTexture(std::vector<std::string> filePath){
            int m_height, m_width, m_BPP;
            unsigned char* m_localBuffer;

            //Generate and bind texture
            GLCall(glGenTextures(1, &m_rendererID));
            GLCall(glBindTexture(GL_TEXTURE_CUBE_MAP, m_rendererID));

            //Storing the pixel data in local buffer
            stbi_set_flip_vertically_on_load(0);
            for(int i=0; i<6; i++){
                m_localBuffer = stbi_load(filePath[i].c_str(), &m_width, &m_height, &m_BPP, 4);
                if(!m_localBuffer){
                    std::cout << "Cannot load '" << filePath[i] << "'" << std::endl;
                    return;
                }
                GLCall(glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X+i, 0, GL_RGBA8, m_width, m_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, m_localBuffer));
                stbi_image_free(m_localBuffer);
            }

            //Specifying the texture properties
            GLCall(glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
            GLCall(glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
            GLCall(glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
            GLCall(glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));
            GLCall(glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE));
        }

        /**
        *Binds the cube map texture into cube-map slot
        */
        void bind(unsigned int slot=0) const{
            GLCall(glActiveTexture(GL_TEXTURE0 + slot));
            GLCall(glBindTexture(GL_TEXTURE_CUBE_MAP, m_rendererID));
        }

        /**
        *Unbinds the current cube map texture
        */
        void unbind() const{
            GLCall(glBindTexture(GL_TEXTURE_CUBE_MAP, 0));
        }

        /**
        *Deletes the cube map texture
        */
        void deleteTexture(){
            GLCall(glDeleteTextures(1, &m_rendererID));
        }
    };
}

/**
*Structure of simple vertex data containing position,normal and uv
*Data to be passed in simple vertex/fragment shader
*/
struct SimpleVertex {
    glm::vec3 position;
    glm::vec3 normal;
    glm::vec2 texCoords;
};

/**
*Data of a pixel of any rgba image format
*/
struct PixelData{
    //unsigned char is used to make it allocate one byte only
    unsigned char r;
    unsigned char g;
    unsigned char b;
    unsigned char a;
};

/**
*Blueprint of object where image data is loaded and manipulated
*/
class Image{
private:
    unsigned char* m_localBuffer;
    int m_height;
    int m_width;
    int m_BPP;

public:
    /**
    *Loads the image into the object's local-buffer
    */
    void loadImage(std::string filePath){
        stbi_set_flip_vertically_on_load(1);
        m_localBuffer = stbi_load(filePath.c_str(), &m_width, &m_height, &m_BPP, 4);
    }

    /**
    *Getter for pixel data at any pixel of image
    */
    PixelData getPixelAt(int i,int j){
        const size_t RGBA = 4;
        unsigned int index = (i+m_width*j)*RGBA;
        unsigned char r = m_localBuffer[index+0];
        unsigned char g = m_localBuffer[index+1];
        unsigned char b = m_localBuffer[index+2];
        unsigned char a = m_localBuffer[index+3];
        return {r,g,b,a};
    }

    /**
    *Getter for width of image
    */
    inline int getWidth(){
        return m_width;
    }

    /**
    *Getter for height of image
    */
    inline int getHeight(){
        return m_height;
    }

    /**
    *Deletes the content of image
    */
    void deleteImage(){
        stbi_image_free(m_localBuffer);
    }
};

//TODO:Make obj mesh both normal mapped and unmapped independent to render by renderer
/**
*Blueprint of objects whose data are to be loaded from obj file type
*No need to make any other data for rendering
*Shader is not predefined inside, shader passed will be used while rendering
*Simple vertex data type of position,normal and uv should be used in shader
*/
class ObjMesh{
private:
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    unsigned int vertex_count;

    /**
    *Takes the string and returns the vector containing the strings
    */
    static std::vector<std::string> splitString(std::string str, char delim = ' '){
        std::vector<std::string> strData;
        std::string tempString = "";
        for(int i=0; str[i]!='\0'; i++){
            if(str[i] == delim){
                tempString += '\n';
                strData.push_back(tempString);
                tempString = "";
                continue;
            }
            tempString += str[i];
        }
        tempString += '\n';
        strData.push_back(tempString);
        return strData;
    }

    /**
    *Reads the data from location and stores in buffers like vertex buffer and index buffer
    */
    void readBuffers(std::string location, float scale){
        std::string line;
        std::ifstream stream(location.c_str());

        std::vector<SimpleVertex> vertices;
        std::vector<glm::vec3> positions;
        std::vector<glm::vec3> normals;
        std::vector<glm::vec2> uvs;

        std::vector<unsigned int> indices;

        if(stream == NULL){
            std::cout << "Cannot Read File" << std::endl;
        }

        while(getline(stream, line) != NULL){
            std::string type;
            std::stringstream ss_datas(line);
            ss_datas >> type;

            if(type == "v"){
                float points[3];
                ss_datas >> points[0] >> points[1] >> points[2];
                positions.push_back(glm::vec3(points[0]*scale, points[1]*scale, points[2]*scale));
            }
            else if (type == "vn"){
                float points[3];
                ss_datas >> points[0] >> points[1] >> points[2];
                normals.push_back(glm::vec3(points[0], points[1], points[2]));
            }
            else if (type == "vt"){
                float points[2];
                ss_datas >> points[0] >> points[1];
                uvs.push_back(glm::vec2(points[0], points[1]));
            }
            else if(type == "f"){
                std::vector<std::string> v_datas = splitString(line);
                for(unsigned int i=1; i<=3; i++){
                    std::vector<std::string> vertex = splitString(v_datas[i], '/');
                    std::stringstream ss_v(vertex[0]);
                    std::stringstream ss_u(vertex[1]);
                    std::stringstream ss_n(vertex[2]);
                    float v_index = 0;
                    float u_index = 0;
                    float n_index = 0;

                    ss_v >> v_index;
                    ss_u >> u_index;
                    ss_n >> n_index;

                    vertices.push_back({positions[v_index-1], normals[n_index-1], uvs[u_index-1]});
                }
            }
        }
        vb.loadData(&vertices[0], vertices.size()*sizeof(SimpleVertex));
        vertex_count = vertices.size();

        vertices.clear();
        positions.clear();
        normals.clear();
        uvs.clear();
    }

public:
    /**
    *Reads obj from @param file location and loads into object
    *Scale defines the scaling of object about local space origin
    */
    void loadFile(std::string fileLocation, float scale = 1){
        readBuffers(fileLocation, scale);

        OpenGL::VertexBufferLayout vbl;
        vbl.pushFloat(3);
        vbl.pushFloat(3);
        vbl.pushFloat(2);

        va.generateVertexArray();
        va.addBuffer(vb, vbl);
    }

    /**
    *binds vertex array and index buffer ready to be rendered
    */
    void bindArray(){
        va.bind();
    }

    /**
    *@return no of indices in obj file
    */
    unsigned int getVertexCount(){
        return vertex_count;
    }

    /**
    *Cleans up data it allocated for rendering and other manipulations
    */
    void cleanUP(){
        va.deleteVertexArray();
        vb.deleteVertexBuffer();
    }
};

/**
*Data format for normal mapped object
*Contains extra data glm::vec3 tangent
*/
struct VertexWithTangentSpace{
    glm::vec3 position;
    glm::vec3 normal;
    glm::vec2 texCords;
    glm::vec3 tangent;
};

/**
*Blueprint of objects whose data are to be loaded from obj file type and normal map is gonna be used
*No need to make any other data for rendering
*Shader is not predefined inside, shader passed will be used while rendering
*Simple vertex data type of position,normal and uv should be used in shader
*/
class ObjMeshNormalMapped{
private:
private:
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    unsigned int vertex_count;

    /**
    *Takes the string and returns the vector containing the strings
    */
    static std::vector<std::string> splitString(std::string str, char delim = ' '){
        std::vector<std::string> strData;
        std::string tempString = "";
        for(unsigned int i=0; str[i]!='\0'; i++){
            if(str[i] == delim){
                tempString += '\n';
                strData.push_back(tempString);
                tempString = "";
                continue;
            }
            tempString += str[i];
        }
        tempString += '\n';
        strData.push_back(tempString);
        return strData;
    }

    /**
    *Reads the data from location and stores in buffers like vertex buffer and index buffer
    */
    void readBuffers(std::string location, float scale){
        std::string line;
        std::ifstream stream(location.c_str());

        std::vector<VertexWithTangentSpace> vertices;
        std::vector<glm::vec3> positions;
        std::vector<glm::vec3> normals;
        std::vector<glm::vec3> tangents;
        std::vector<glm::vec2> uvs;

        std::vector<unsigned int> indices;

        if(stream == NULL){
            std::cout << "Cannot Read File" << std::endl;
        }

        while(getline(stream, line) != NULL){
            std::string type;
            std::stringstream ss_datas(line);
            ss_datas >> type;

            if(type == "v"){
                float points[3];
                ss_datas >> points[0] >> points[1] >> points[2];
                positions.push_back(glm::vec3(points[0]*scale, points[1]*scale, points[2]*scale));
            }
            else if (type == "vn"){
                float points[3];
                ss_datas >> points[0] >> points[1] >> points[2];
                normals.push_back(glm::vec3(points[0], points[1], points[2]));
            }
            else if (type == "vt"){
                float points[2];
                ss_datas >> points[0] >> points[1];
                uvs.push_back(glm::vec2(points[0], points[1]));
            }
            else if(type == "f"){
                std::vector<std::string> v_datas = splitString(line);
                glm::vec3 temp_pos[3];
                glm::vec3 temp_normal[3];
                glm::vec2 temp_uv[3];
                for(unsigned int i=1; i<=3; i++){
                    std::vector<std::string> vertex = splitString(v_datas[i], '/');
                    std::stringstream ss_v(vertex[0]);
                    std::stringstream ss_u(vertex[1]);
                    std::stringstream ss_n(vertex[2]);
                    float v_index = 0;
                    float u_index = 0;
                    float n_index = 0;

                    ss_v >> v_index;
                    ss_u >> u_index;
                    ss_n >> n_index;

                    temp_pos[i-1] = positions[v_index-1];
                    temp_normal[i-1] = normals[n_index-1];
                    temp_uv[i-1] = uvs[u_index-1];
                }

                glm::vec3 del_pos1 = temp_pos[1]-temp_pos[0];
                glm::vec3 del_pos2 = temp_pos[2]-temp_pos[0];
                glm::vec2 del_uv1 = temp_uv[1]-temp_uv[0];
                glm::vec2 del_uv2 = temp_uv[2]-temp_uv[0];
                float r = 1/(del_uv1.x*del_uv2.y - del_uv1.y*del_uv2.x);
                glm::vec3 temp_tangent = (del_pos1*del_uv2.y)-(del_pos2*del_uv1.y);
                temp_tangent *= r;

                for(int i=0;i<3;i++){
                    vertices.push_back({temp_pos[i], temp_normal[i], temp_uv[i], temp_tangent});
                }
            }
        }
        vb.loadData(&vertices[0], vertices.size()*sizeof(VertexWithTangentSpace));
        vertex_count = vertices.size();

        vertices.clear();
        positions.clear();
        normals.clear();
        uvs.clear();
    }

public:
    /**
    *Reads obj from @param file location and loads into object
    *Scale defines the scaling of the object about local space origin
    */
    void loadFile(std::string fileLocation, float scale = 1){
        readBuffers(fileLocation, scale);

        OpenGL::VertexBufferLayout vbl;
        vbl.pushFloat(3);
        vbl.pushFloat(3);
        vbl.pushFloat(2);
        vbl.pushFloat(3);

        va.generateVertexArray();
        va.addBuffer(vb, vbl);
    }

    /**
    *binds vertex array and index buffer ready to be rendered
    */
    void bindArray(){
        va.bind();
    }

    /**
    *@return no of indices in obj file
    */
    unsigned int getVertexCount(){
        return vertex_count;
    }

    /**
    *Cleans up the memory it allocated
    */
    void cleanUP(){
        va.deleteVertexArray();
        vb.deleteVertexBuffer();
    }
};

/**
*Blueprint for sky box object
*Individual objects will have its own shader considering there will be one or few sky box only
*No need to initialize any other data types to use it
*Users can increase or set the rotation value of sky-box to give 3D-effect
*/
class SkyBox{
private:
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    OpenGL::CubeMap cm;
    OpenGL::Shader shader;
    static const float DEFAULT_ROTATION_SPEED = 0.0075;
    float rotation = 0.0;
public:

    /**
    *Load the sky-box object with sky-boxes textures and shader
    *@param skyBoxes: file location of 6 sky-box images
    *@param shaderFile: file location of shader to be used in sky-box
    *@param cameraFar: far point of camera for ensuring that sky-box never clips off the camera
    *@param fogColor: array of fogColor in RGB
    */
    void loadSkyBox(std::vector<std::string> skyBoxes, std::string shaderFile, float cameraFar, float* fogColor){
        cm.loadTexture(skyBoxes);
        shader.loadShader(shaderFile);
        shader.bind();
        shader.addUniform1i("cubeMap", 0);//Slot of cube-map texture
        shader.addUniform3f("fogColor", fogColor);//Color of fog to be used in sky-box

        const float SIZE = cameraFar/1.8;//Ensuring that diagonal of the cube is also covered by vamera
        float positions[]={
            -SIZE,  SIZE, -SIZE,
            -SIZE, -SIZE, -SIZE,
             SIZE, -SIZE, -SIZE,
             SIZE, -SIZE, -SIZE,
             SIZE,  SIZE, -SIZE,
            -SIZE,  SIZE, -SIZE,

            -SIZE, -SIZE,  SIZE,
            -SIZE, -SIZE, -SIZE,
            -SIZE,  SIZE, -SIZE,
            -SIZE,  SIZE, -SIZE,
            -SIZE,  SIZE,  SIZE,
            -SIZE, -SIZE,  SIZE,

             SIZE, -SIZE, -SIZE,
             SIZE, -SIZE,  SIZE,
             SIZE,  SIZE,  SIZE,
             SIZE,  SIZE,  SIZE,
             SIZE,  SIZE, -SIZE,
             SIZE, -SIZE, -SIZE,

            -SIZE, -SIZE,  SIZE,
            -SIZE,  SIZE,  SIZE,
             SIZE,  SIZE,  SIZE,
             SIZE,  SIZE,  SIZE,
             SIZE, -SIZE,  SIZE,
            -SIZE, -SIZE,  SIZE,

            -SIZE,  SIZE, -SIZE,
             SIZE,  SIZE, -SIZE,
             SIZE,  SIZE,  SIZE,
             SIZE,  SIZE,  SIZE,
            -SIZE,  SIZE,  SIZE,
            -SIZE,  SIZE, -SIZE,

            -SIZE, -SIZE, -SIZE,
            -SIZE, -SIZE,  SIZE,
             SIZE, -SIZE, -SIZE,
             SIZE, -SIZE, -SIZE,
            -SIZE, -SIZE,  SIZE,
             SIZE, -SIZE,  SIZE
        };

        va.generateVertexArray();
        vb.loadData(positions, 36*3*sizeof(float));
        OpenGL::VertexBufferLayout vbl;
        vbl.pushFloat(3);
        va.addBuffer(vb, vbl);
    }

    /**
    *Users are allowed to rotate sky-box to give 3D feeling of sky-box
    */
    void setRotation(float rotation_value){
        rotation = rotation_value;
        if(rotation >=360)
            rotation = 0.0;
    }

    /**
    *Increase the rotation value of the sky-box
    */
    void increaseRotation(float delta = DEFAULT_ROTATION_SPEED){
        rotation += delta;
        if(rotation >=360)
            rotation = 0.0;
    }

    void draw(glm::mat4 view, glm::mat4 projection){
        shader.bind();
        //Removing translation for sky box
        //i.e camera always stays at center for sky-box
        view[3].x = 0;
        view[3].y = 0;
        view[3].z = 0;
        view[3].w = 1;
        view = glm::rotate(view, glm::radians(rotation), glm::vec3(0.0, 1.0, 0.0));
        glm::mat4 mvp = projection*view;
        shader.addUniformMat4f("u_mvp", mvp);
        va.bind();
        cm.bind();
        GLCall(glDrawArrays(GL_TRIANGLES, 0, 36));
    }

    void cleanUP(){
        va.deleteVertexArray();
        vb.deleteVertexBuffer();
        shader.deleteShader();
        cm.deleteTexture();
    }
};

struct terrainVertex{
    glm::vec3 position;
    glm::vec3 normal;
    glm::vec2 uv;
    glm::vec2 mapUV;
};

class Terrain{
    private:
        static const float maxHeight = 20.0f;
        //Scaling of texture with actual terrain data
        float x_scaling;
        float z_scaling;
        float gridSize;
        OpenGL::VertexArray va;
        OpenGL::VertexBuffer vb;
        OpenGL::Texture texture[5];
        OpenGL::Texture depthTexture;
        Image height;
        OpenGL::Shader shader;
        unsigned int num_vertices;
        std::vector< std::vector<float> > height_values;

        float getHeight(float x,float z){
            if(x<0 || x>height.getWidth() || z<0 || z>height.getHeight()){
                return 0;
            }
            PixelData pixel = height.getPixelAt(x, z);
            float result = (pixel.r + pixel.g + pixel.b)/3;
            result = result*2 - 255;
            result = result*maxHeight/255.0;
            return result;
        }

        void calculateVertices(float tileSize, float length, float width){
            glm::vec3 pos1, pos2, pos3;
            glm::vec2 uv1, uv2, uv3;
            glm::vec2 mapuv1, mapuv2, mapuv3;
            glm::vec3 normal = glm::vec3(0, 1, 0);
            std::vector<terrainVertex> vertices;

            float i_loop = length/tileSize;
            float j_loop = width/tileSize;
            x_scaling = height.getWidth()/length;
            z_scaling = height.getHeight()/width;
            this->gridSize = tileSize;

            for(int i = 0 ; i < (i_loop); i++){
                std::vector<float> zAxisHeights;
                for(int j=0; j < (j_loop); j++){
                    pos1 = glm::vec3(i* tileSize, getHeight(i*height.getWidth()/i_loop, j*height.getHeight()/j_loop), -(j*tileSize));
                    uv1 = glm::vec2(0, 0);
                    mapuv1 = glm::vec2(i/i_loop, j/j_loop);

                    pos2 = glm::vec3((i+1)* tileSize, getHeight((i+1)*height.getWidth()/i_loop, j*height.getHeight()/j_loop), -(j*tileSize));
                    uv2 = glm::vec2(1, 0);
                    mapuv2 = glm::vec2((i+1)/i_loop, j/j_loop);

                    pos3 = glm::vec3((i+1)* tileSize, getHeight((i+1)*height.getWidth()/i_loop, (j+1)*height.getHeight()/j_loop), -((j+1)*tileSize));
                    uv3 = glm::vec2(1, 1);
                    mapuv3 = glm::vec2((i+1)/i_loop, (j+1)/j_loop);

                    vertices.push_back({pos1, normal, uv1, mapuv1});
                    vertices.push_back({pos2, normal, uv2, mapuv2});
                    vertices.push_back({pos3, normal, uv3, mapuv3});
                    zAxisHeights.push_back(pos1.y);

                    pos1 = glm::vec3(i* tileSize, getHeight(i*height.getWidth()/i_loop, j*height.getHeight()/j_loop), -(j*tileSize));
                    uv1 = glm::vec2(0, 0);
                    mapuv1 = glm::vec2(i/i_loop, j/j_loop);

                    pos2 = glm::vec3((i+1)* tileSize, getHeight((i+1)*height.getWidth()/i_loop, (j+1)*height.getHeight()/j_loop), -((j+1)*tileSize));
                    uv2 = glm::vec2(1, 1);
                    mapuv2 = glm::vec2((i+1)/i_loop, (j+1)/j_loop);

                    pos3 = glm::vec3(i* tileSize, getHeight(i*height.getWidth()/i_loop, (j+1)*height.getHeight()/j_loop), -((j+1)*tileSize));
                    uv3 = glm::vec2(0, 1);
                    mapuv3 = glm::vec2((i)/i_loop, (j+1)/j_loop);

                    vertices.push_back({pos1, normal, uv1, mapuv1});
                    vertices.push_back({pos2, normal, uv2, mapuv2});
                    vertices.push_back({pos3, normal, uv3, mapuv3});
                }
                height_values.push_back(zAxisHeights);
                zAxisHeights.clear();
            }
            num_vertices = vertices.size();
            vb.loadData(&vertices[0], sizeof(terrainVertex)*vertices.size());
            vertices.clear();
        }

    public:
        void loadTerrain(std::string shaderLocation, std::vector<std::string> textureLoactions, std::string heightMap,float tileSize, float length,float width){
            shader.loadShader(shaderLocation);
            shader.bind();
            {
                float direction[] = {0.0f, -1.0f, 0.5f};
                float a_color[] = {1.0f, 1.0f, 1.0f};
                float d_color[] = {1.0f, 1.0f, 1.0f};
                float s_color[] = {1.0f, 1.0f, 1.0f};

                shader.addUniform3f("dlight.direction", direction);
                shader.addUniform3f("dlight.ambient", a_color);
                shader.addUniform3f("dlight.diffuse", d_color);
                shader.addUniform3f("dlight.specular", s_color);
            }

            {
                float shininess = 32.0f;
                float a_color[] = {0.2f, 0.2f, 0.2f};
                float d_color[] = {1.0f, 1.0f, 1.0f};
                float s_color[] = {1.0f, 1.0f, 1.0f};

                shader.addUniform1f("material.shininess", shininess);
                shader.addUniform3f("material.ambient", a_color);
                shader.addUniform3f("material.diffuse", d_color);
                shader.addUniform3f("material.specular", s_color);
            }

            {
                float sky[]={0.40, 0.50, 0.60};
                shader.addUniform3f("u_skyColor",sky);
                shader.addUniform1i("backSlot", 0);
                shader.addUniform1i("rSlot", 1);
                shader.addUniform1i("gSlot", 2);
                shader.addUniform1i("bSlot", 3);
                shader.addUniform1i("mapSlot", 4);
                shader.addUniform1i("depthSlot", 5);
            }

            //texture.loadTexture(terrainTexture);
            for(int i=0; i<5; i++)
                texture[i].loadTexture(textureLoactions[i]);
            height.loadImage(heightMap);

            calculateVertices(tileSize, length, width);

            OpenGL::VertexBufferLayout vbl;
            vbl.pushFloat(3);
            vbl.pushFloat(3);
            vbl.pushFloat(2);
            vbl.pushFloat(2);

            va.generateVertexArray();
            va.addBuffer(vb, vbl);
        }

        /**
        *Shadow loader should bind texture in shadow depth slot to get shadow
        */
        void draw(glm::mat4 view, glm::mat4 projection, glm::mat4 lightSpace = glm::mat4(1.0),
                    glm::vec4 clippingPlane= glm::vec4(0.0, -1.0, 0.0, 20.0)){
            for(unsigned int i=0; i<5; i++)
                texture[i].bind(i);

            shader.bind();
            shader.addUniformMat4f("u_view", view);
            shader.addUniformMat4f("u_projection", projection);
            shader.addUniform4f("u_clipPlane", clippingPlane);
            shader.addUniformMat4f("u_lightSpace", lightSpace);
            va.bind();

            GLCall(glDrawArrays(GL_TRIANGLES, 0, num_vertices));
        }

        void draw(glm::mat4 mvp, OpenGL::Shader shader){
            shader.bind();
            shader.addUniformMat4f("mvp", mvp);
            va.bind();
            GLCall(glDrawArrays(GL_TRIANGLES, 0, num_vertices));
        }

        /**
        *Expected value negative in Z & positive in X
        *@return value of height at any point on terrain
        */
        float getHeightAt(float x, float z){
            float index_x = x/gridSize;
            float index_z = -z/gridSize;
            //Return 0 if not within stored range
            if(index_x >= height_values.size() || index_z >= height_values[0].size()){
                return 0;
            }

            //Index value of button left point
            int x0 = (int)index_x;
            int z0 = (int)index_z;

            //Index value of top right point
            int x1 = x0+1;
            int z1 = z0+1;

            //Button right corner by default
            int x2 = x1;
            int z2 = z0;
            //Calculating where on side of triangle point exists
            glm::vec2 buttomLeft = glm::vec2(x0*gridSize, z0*gridSize);
            glm::vec2 pointFromButtomLeft = glm::vec2(x,-z) - buttomLeft;
            glm::vec3 normal;
            glm::vec3 pos[3];

            //If point is in topside of triangle
            if(pointFromButtomLeft.y > pointFromButtomLeft.x){
                x2 = x0;
                z2 = z1;
            }
            float heightFloat[] = {
                height_values[x0][z0],
                height_values[x1][z1],
                height_values[x2][z2]
            };
            pos[0] = glm::vec3(x0*gridSize, heightFloat[0], z0*gridSize);
            pos[1] = glm::vec3(x1*gridSize, heightFloat[1], z1*gridSize);
            pos[2] = glm::vec3(x2*gridSize, heightFloat[2], z2*gridSize);

            glm::vec3 vecA = pos[1] - pos[0];
            glm::vec3 vecB = pos[2] - pos[0];
            normal = glm::cross(vecA, vecB);

            float A,B,C,D;
            A = normal.x;
            B = normal.y;
            C = normal.z;
            D = A*pos[0].x + B*pos[0].y + C*pos[0].z;

            return (D - A*x + C*z)/B;
        }

        unsigned int shadowDepthSlot(){
            return 5;
        }

        void cleanUP(){
            shader.deleteShader();
            height.deleteImage();
            for(int i=0; i<5; i++){
                texture[i].deleteTexture();
            }
            height_values.clear();
            va.deleteVertexArray();
            vb.deleteVertexBuffer();
        }
};

class NormalMappedObject{
private:
    ObjMeshNormalMapped object;
    OpenGL::Texture colorTexture;
    OpenGL::Texture normalMap;
    static OpenGL::Shader shader;
public:
    void loadObject(std::string objLocation, std::string textureLocation, std::string normalMapLocation, float scaling=1){
        object.loadFile(objLocation, scaling);
        colorTexture.loadTexture(textureLocation);
        normalMap.loadTexture(normalMapLocation);
    }

    static void specifyShader(std::string shaderLocation, glm::vec3 lightColor, glm::vec3 lightDirection){
        shader.loadShader(shaderLocation);
        shader.bind();
        shader.addUniform1i("u_colorSampler",0);
        shader.addUniform1i("u_normalSampler",1);

        lightDirection = glm::normalize(lightDirection);
        float color[]={lightColor.x, lightColor.y, lightColor.z};
        float direction[]={lightDirection.x, lightDirection.y, lightDirection.z};
        shader.addUniform3f("u_lightColor", color);
        shader.addUniform3f("u_lightDirection", direction);
    }

    void draw(glm::mat4 model, glm::mat4 view, glm::mat4 projection, glm::vec3 camPosition){
        float position[]={camPosition.x, camPosition.y, camPosition.z};
        colorTexture.bind();
        normalMap.bind(1);
        shader.bind();
        shader.addUniformMat4f("u_model", model);
        shader.addUniformMat4f("u_view", view);
        shader.addUniformMat4f("u_projection", projection);
        shader.addUniform3f("u_viewPosition", position);
        object.bindArray();
        GLCall(glDrawArrays(GL_TRIANGLES, 0, object.getVertexCount()));
    }
};

class Props{
private:
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    unsigned int vertex_count;
    std::vector<SimpleVertex> vertices;
    OpenGL::Texture itemsTexture;
    unsigned int grid_items;

    /**
    *Takes the string and returns the vector containing the strings
    */
    static std::vector<std::string> splitString(std::string str, char delim = ' '){
        std::vector<std::string> strData;
        std::string tempString = "";
        for(unsigned int i=0; str[i]!='\0'; i++){
            if(str[i] == delim){
                tempString += '\n';
                strData.push_back(tempString);
                tempString = "";
                continue;
            }
            tempString += str[i];
        }
        tempString += '\n';
        strData.push_back(tempString);
        return strData;
    }

    /**
    *Adds the data from the Location to vertices buffer
    */
    void readBuffers(std::string location, glm::vec3 offset_position, float scaling, unsigned int x_grid, unsigned int y_grid, bool upNormal){
        std::string line;
        std::ifstream stream(location.c_str());
        std::vector<glm::vec3> positions;
        std::vector<glm::vec3> normals;
        std::vector<glm::vec2> uvs;
        std::vector<unsigned int> indices;

        float uv_scaling = 1/(float)grid_items;

        if(stream == NULL){
            std::cout << "Cannot Read File" << std::endl;
        }

        while(getline(stream, line) != NULL){
            std::string type;
            std::stringstream ss_datas(line);
            ss_datas >> type;

            if(type == "v"){
                float points[3];
                ss_datas >> points[0] >> points[1] >> points[2];
                points[0]=points[0]*scaling + offset_position.x;
                points[1]=points[1]*scaling + offset_position.y;
                points[2]=points[2]*scaling + offset_position.z;
                positions.push_back(glm::vec3(points[0], points[1], points[2]));
            }
            else if (type == "vn"){
                float points[3];
                ss_datas >> points[0] >> points[1] >> points[2];

                if(upNormal)
                    normals.push_back(glm::vec3(0.0, 1.0, 0.0));
                else
                    normals.push_back(glm::vec3(points[0], points[1], points[2]));
            }
            else if (type == "vt"){
                float points[2];
                ss_datas >> points[0] >> points[1];
                points[0] *= uv_scaling;
                points[1] *= uv_scaling;
                points[0] += (float)x_grid*uv_scaling;
                points[1] += (float)y_grid*uv_scaling;
                uvs.push_back(glm::vec2(points[0], points[1]));
            }
            else if(type == "f"){
                std::vector<std::string> v_datas = splitString(line);
                for(unsigned int i=1; i<=3; i++){
                    std::vector<std::string> vertex = splitString(v_datas[i], '/');
                    std::stringstream ss_v(vertex[0]);
                    std::stringstream ss_u(vertex[1]);
                    std::stringstream ss_n(vertex[2]);
                    float v_index = 0;
                    float u_index = 0;
                    float n_index = 0;

                    ss_v >> v_index;
                    ss_u >> u_index;
                    ss_n >> n_index;

                    vertices.push_back({positions[v_index-1], normals[n_index-1], uvs[u_index-1]});
                }
            }
        }
        positions.clear();
        normals.clear();
        uvs.clear();
    }

public:

    void loadTexture(std::string filePath, unsigned int grid_items=1){
        this->grid_items = grid_items;
        itemsTexture.loadTexture(filePath);
    }

    /**
    *@param objLocation is location of obj file
    *@param x_grid and y_grid is the location of texture in grid to be used and count starts from zero
    *@param position is position of current obj file
    */
    void pushItem(std::string objLocation, unsigned int x_grid=0, unsigned int y_grid=0 ,glm::vec3 position=glm::vec3(0.0, 0.0, 0.0),float scaling=1.0, bool upNormal=false){
        if(x_grid>=grid_items || y_grid>=grid_items)
            return;
        readBuffers(objLocation, position,scaling, x_grid, y_grid, upNormal);
    }

    /**
    *After all items are pushed, then it sores the data from vector into buffer
    */
    void allItemsPushed(){
        vb.loadData(&vertices[0], vertices.size()*sizeof(SimpleVertex));
        vertex_count = vertices.size();
        vertices.clear();

        OpenGL::VertexBufferLayout vbl;
        vbl.pushFloat(3);
        vbl.pushFloat(3);
        vbl.pushFloat(2);

        va.generateVertexArray();
        va.addBuffer(vb, vbl);
    }

    void render(OpenGL::Shader shader){
        Window::disableBackfaceCulling();
        shader.bind();
        va.bind();
        itemsTexture.bind();
        GLCall(glDrawArrays(GL_TRIANGLES, 0, vertex_count));
        Window::enableBackfaceCulling();
    }

    void cleanUP(){
        va.deleteVertexArray();
        vb.deleteVertexBuffer();
        itemsTexture.deleteTexture();
    }
};

namespace Animation{
    //Data structure for VAO
    struct AnimationData{
        glm::vec3 position;
        glm::vec3 normals;
        glm::vec2 uvs;
        glm::uvec3 joints;
        glm::vec3 weights;
    };

    //Representing each joint
    struct Joint{
        unsigned int id;//Id of joint (each should have unique id)
        std::string name;//Name
        std::vector<Joint> children;//List of children
        glm::mat4 invertedBindTransform;//Transformation in relation to origin but directed towards origin
        glm::mat4 animatedTransform;//Transformation to be applied for new animating transformation

        /**
        *Loads the data to joint
        */
        void loadJoint(unsigned int ID, std::string NAME){
            id = ID;
            name = NAME;
        }

        /**
        *Adds child to current children list
        */
        void addChild(Joint child){
            children.push_back(child);
        }
    };

    //Representing angle by 4 component of vectors
    struct Quaternion{
        glm::vec4 angle;

        /**
        *Normalizes the vector
        */
        void normalize(){
            angle = glm::normalize(angle);
        }

        /**
        *Converts the quaternion to matrix containing rotation part
        */
        glm::mat4 toRotationMatrix(){
            float data[4][4];

            data[0][0] = 1.0-2.0*(angle.y*angle.y+angle.z*angle.z);
            data[0][1] = 2.0*(angle.x*angle.y - angle.z*angle.w);
            data[0][2] = 2.0*(angle.x*angle.z + angle.y*angle.w);
            data[0][3] = 0.0;
            data[1][0] = 2.0*(angle.x*angle.y + angle.z*angle.w);
            data[1][1] = 1.0-2.0*(angle.x*angle.x+angle.z*angle.z);
            data[1][2] = 2.0*(angle.y*angle.z - angle.x*angle.w);
            data[1][3] = 0.0;
            data[2][0] = 2.0*(angle.x*angle.z - angle.y*angle.w);
            data[2][1] = 2.0*(angle.y*angle.z + angle.x*angle.w);
            data[2][2] = 1.0-2.0*(angle.x*angle.x + angle.y*angle.y);
            data[2][3] = 0.0;
            data[3][0] = 0.0;
            data[3][1] = 0.0;
            data[3][2] = 0.0;
            data[3][3] = 1.0;
            return glm::mat4(data[0][0], data[0][1], data[0][2], data[0][3],
                             data[1][0], data[1][1], data[1][2], data[1][3],
                             data[2][0], data[2][1], data[2][2], data[2][3],
                             data[3][0], data[3][1], data[3][2], data[3][3]);
        }

        /**
        *Converts transformation matrix into quaternion
        */
        static Quaternion loadFromMatrix(glm::mat4 matrix){
            float x,y,z,w;
            float diagonal = matrix[0][0]+matrix[1][1]+matrix[2][2];
            if(diagonal > 0){
                float w4 = 2*sqrt(diagonal+1.0);
                x = (matrix[2][1] - matrix[1][2])/w4;
                y = (matrix[0][2] - matrix[2][0])/w4;
                z = (matrix[1][0] - matrix[0][1])/w4;
                w = w4/4.0;
            }
            else if((matrix[0][0]>matrix[1][1]) && (matrix[0][0]>matrix[2][2])){
                float x4 = 2*sqrt(1.0+matrix[0][0]-matrix[1][1]-matrix[2][2]);
                x = x4/4.0;
                y = (matrix[1][0] + matrix[0][1])/x4;
                z = (matrix[0][2] + matrix[2][0])/x4;
                w = (matrix[2][1] - matrix[1][2])/x4;
            }
            else if(matrix[1][1]>matrix[2][2]){
                float y4 = 2*sqrt(1-matrix[0][0]+matrix[1][1]-matrix[2][2]);
                x = (matrix[1][0] + matrix[0][1])/y4;
                y = y4/4.0;
                z = (matrix[2][1] + matrix[1][2])/y4;
                w = (matrix[0][2] - matrix[2][0])/y4;
            }
            else{
                float z4 = 2*sqrt(1-matrix[0][0]-matrix[1][1]+matrix[2][2]);
                x = (matrix[0][2] + matrix[2][0])/z4;
                y = (matrix[2][1] + matrix[1][2])/z4;
                z = z4/4.0;
                w = (matrix[1][0] - matrix[0][1])/z4;
            }

            Quaternion result;
            result.angle = glm::vec4(x,y,z,w);
            return result;
        }

        /**
        *Interpolates between quaternions depending upon blend
        */
        static Quaternion interPolate(Quaternion a,Quaternion b,float blend){
            Quaternion result;
            float x,y,z,w;
            float dot = a.angle.x*b.angle.x + a.angle.y*b.angle.y + a.angle.z*b.angle.z;
            float blend_inverse = 1-blend;
            if(dot < 0){
                result.angle = blend_inverse*a.angle - blend*b.angle;
    //            x = blend_inverse*a.angle.x - blend*b.angle.x;
    //            y = blend_inverse*a.angle.y - blend*b.angle.y;
    //            z = blend_inverse*a.angle.z - blend*b.angle.z;
    //            w = blend_inverse*a.angle.w - blend*b.angle.w;
            }
            else{
                result.angle = blend_inverse*a.angle + blend*b.angle;
    //            x = blend_inverse*a.angle.x + blend*b.angle.x;
    //            y = blend_inverse*a.angle.y + blend*b.angle.y;
    //            z = blend_inverse*a.angle.z + blend*b.angle.z;
    //            w = blend_inverse*a.angle.w + blend*b.angle.w;
            }
            result.normalize();
            return result;
        }
    };

    //Represents the transformation of each joint relation to its parent
    struct JointTransform{
    glm::vec3 position;//Position of joint
    Quaternion rotation;//Rotation of joint

    /**
    *Converts the joint transform to transformation matrix
    */
    glm::mat4 getLocalTransform(){
        glm::mat4 result = glm::translate(glm::mat4(1.0), position);
        result = result*rotation.toRotationMatrix();//Rotation first
        //result = rotation.toRotationMatrix()*result;//Translation first
        return result;
    }

    /**
    *Interpolates 3 components of vector i.e generally position
    */
    static glm::vec3 interpolatePosition(glm::vec3 startPosition, glm::vec3 endPosition, float progress){
        glm::vec3 diff = endPosition-startPosition;
        glm::vec3 result = startPosition + progress*diff;
    //    result.x = startPosition.x + progress*diff.x;
    //    result.y = startPosition.y + progress*diff.y;
    //    result.z = startPosition.z + progress*diff.z;
        return result;
    }

    /**
    *Interpolates the joint transformation depending upon progress
    */
    static JointTransform interpolate(JointTransform posA, JointTransform posB, float progress){
        JointTransform result;
        result.position = interpolatePosition(posA.position, posB.position, progress);
        result.rotation = Quaternion::interPolate(posA.rotation, posB.rotation, progress);
        return result;
    }

    /**
    *Converts the transformation matrix to joint transform
    */
    static JointTransform loadFromMatrix(glm::mat4 matrix){
        JointTransform result;
        result.rotation = Quaternion::loadFromMatrix(matrix);
        result.position = glm::vec3(matrix[3][0], matrix[3][1], matrix[3][2]);
        return result;
    }

    };

    //Represents hash map of joint id and its transforms
    struct JointMap{
        std::vector<JointTransform> jointTransforms;//Transformation of joints
        std::vector<unsigned int> ids;//IDs of corresponding joints

        /**
        *Returns joint transform of the joint having @param id
        */
        JointTransform getValue(unsigned int id){
            //Searching for matching id
            for(int i=0; i<ids.size(); i++){
                if(ids[i]==id){
                    return jointTransforms[i];
                }
            }
            //If no id found then return dummy transform
            JointTransform jointTransform = JointTransform::loadFromMatrix(glm::mat4(1.0));
            std::cout<<"Warning::No ids found in joint-map!!"<<std::endl;
            return jointTransform;
        }

        /**
        *Adds the data to joint map
        */
        void pushValue(JointTransform jointTransform, unsigned int id){
            //Check if id already exists
            for(unsigned int i=0; i<ids.size(); i++){
                if(ids[i]==id){
                    //If exists then replace old transform with new one
                    jointTransforms[i] = jointTransform;
                    std::cout<<"Warning::Old transforms being replaced!!!"<<std::endl;
                    return;
                }
            }
            jointTransforms.push_back(jointTransform);
            ids.push_back(id);
        }

        /**
        *Clears the value of the map
        */
        void flushValues(){
            jointTransforms.clear();
            ids.clear();
        }
    };

    //Representing each key-frame of animation
    struct KeyFrame{
    JointMap jointTransforms;
    float timeStamp;
    //Assuming that all joint animation have same time-stamp

    /**
    *Adds transformations of joint
    */
    void addJointTransforms(JointTransform jointTransform,unsigned int jointID){
        jointTransforms.pushValue(jointTransform, jointID);
    }
    };

    //Represents the complete set of key-frames
    struct Animation{
    std::vector<KeyFrame> keyFrames;
    float length;//Total length of animation
    };

    //Animates the animation set in for function
    class Animator{
    private:
        Animation currentAnimation;//Animation to be animated
        float animationTime;//Time elapsed in seconds
        bool animationLoop;//Whether to loop the animation or not

        /**
        *Increases the time value after each call
        */
        void increaseTime(int fps){
            animationTime += 1.0/(float)fps;
            //TODO:: Implement looping in animation
            if(animationTime > currentAnimation.length){
                animationTime = 0;
            }
        }

        /**
        *Calculates the frames to be interpolated for animation
        *first value is previous frame and second value is next frame
        */
        std::vector<KeyFrame> getNextAndPreviousFrame(){
            //For safety reason if there is only one key frame
            KeyFrame prevFrame = currentAnimation.keyFrames[0];
            KeyFrame nextFrame = currentAnimation.keyFrames[0];

            for(unsigned int i=1; i<currentAnimation.keyFrames.size(); i++){
                nextFrame = currentAnimation.keyFrames[i];
                if(nextFrame.timeStamp > animationTime){
                    prevFrame = currentAnimation.keyFrames[i-1];
                    break;
                }
            }

            std::vector<KeyFrame> result;
            result.push_back(prevFrame);
            result.push_back(nextFrame);
            return result;
        }

        /**
        *Calculates the progress between previous and next key-frame
        */
        float calculateProgress(std::vector<KeyFrame> prevAndNextframe){
            float totalTime = prevAndNextframe[1].timeStamp - prevAndNextframe[0].timeStamp; //Time gap between next and previous
            float currentTime = animationTime - prevAndNextframe[0].timeStamp; //time gap w.r.t previous key frame
            return currentTime/totalTime;
        }

        /**
        *Interpolates the joint map from previous and next key-frame
        */
        JointMap interpolateBones(KeyFrame prevframe, KeyFrame nextframe, float progress){
            JointMap currentPose;
            //Interpolate each transforms from key-frame joint map
            for(unsigned int i=0; i<prevframe.jointTransforms.ids.size(); i++){
                unsigned int jointID = prevframe.jointTransforms.ids[i];
                JointTransform prevTransform = prevframe.jointTransforms.jointTransforms[i];//.getValue(jointID);
                JointTransform nextTransform = nextframe.jointTransforms.jointTransforms[i];//.getValue(jointID);
                JointTransform currentTransform = JointTransform::interpolate(prevTransform,nextTransform,progress);
                currentPose.pushValue(currentTransform, jointID);
            }
            return currentPose;
        }

        /**
        *Calculates and returns the current pose depending upon time and key frame
        */
        JointMap calculateCurrentPose(){
            std::vector<KeyFrame> frames = getNextAndPreviousFrame();
            float progress = calculateProgress(frames);
            return interpolateBones(frames[0], frames[1], progress);
            //return interpolateBones(currentAnimation.keyFrames[0], currentAnimation.keyFrames[1], 0.0);
        }

        /**
        *Applies the joint transformation to joint
        */
        void applyPoseToJoints(Joint& rootJoint, JointMap pose, glm::mat4 parentTransform){
            //Accessing the transformation from current pose using name of root joint
            glm::mat4 localTransformation = pose.getValue(rootJoint.id).getLocalTransform();
            glm::mat4 currentTransform = parentTransform*localTransformation;
            rootJoint.animatedTransform = currentTransform*rootJoint.invertedBindTransform;
            //Apply pose to all children joints
            for(unsigned int i=0; i<rootJoint.children.size(); i++){
                applyPoseToJoints(rootJoint.children[i], pose, currentTransform);
            }
        }
    public:
        void setAnimation(Animation animation){
            animationTime = 0.0;
            currentAnimation = animation;
        }

         void animate(int fps, Joint& rootJoint){
            increaseTime(fps);
            JointMap pose = calculateCurrentPose();
            applyPoseToJoints(rootJoint, pose, glm::mat4(1.0));
        }

    };

    //Represents each joint in the hierarchy
    struct JointHeirarchy{
        std::vector<unsigned int> position;//Position in hierarchy
        std::string name;//Name in hierarchy
        unsigned int id;
    };

    //Represents each animation data of a joint
    struct AnimationIO{
        std::vector<glm::mat4> transforms;//Bind transformations at different time-steps
    };

    //Model that can be animated
    class AnimatedModel{
    private:
        OpenGL::VertexArray va;
        OpenGL::VertexBuffer vb;
        OpenGL::Texture texture;
        Joint rootJoint;
        unsigned int vertexCount;
        Animator animator;//Animates the current animation
        //std::vector<Animation> animations;//List of all animations model can have
        std::vector<glm::mat4> transformations;//Transformation of joints arranged according to its id
        static OpenGL::Shader shader;//Shader to be applied in model

        /**
        *Takes the string and returns the vector containing the strings splitting string by @param character
        */
        static std::vector<std::string> splitString(std::string str, char delim = ' '){
            std::vector<std::string> strData;
            std::string tempString = "";
            for(int i=0; str[i]!='\0'; i++){
                if(str[i] == delim){
                    strData.push_back(tempString);
                    tempString = "";
                    continue;
                }
                tempString += str[i];
            }
            strData.push_back(tempString);
            return strData;
        }

        /**
        *Removes all repetitive first characters from the string
        */
        static std::string removeAllFirstCharacter(std::string str){
            std::string data = "";
            int lastI;
            char character = str[0];

            //Find the index at which character ends
            for(unsigned int i=1; i<str.size(); i++){
                if(str[i] != character){
                    lastI = i;
                    break;
                }
            }

            //Start copying data from that index
            for(unsigned int i=lastI; i<str.size(); i++){
                data += str[i];
            }
            return data;
        }

        /**
        *Reads Collada file format and loads the data to VAO and joints
        */
        void parseCollada(std::string colladaFile){
            //Specifying the library-types
            enum {
             NONE = -1, GEOMETRY, ANIMATIONS, CONTROLLERS, SCENES
            };

            std::string line;
            std::ifstream stream(colladaFile.c_str());
            int libraryType = NONE;

            std::vector<AnimationData> vertices;
            std::vector<glm::vec3> positions;
            std::vector<glm::vec3> normals;
            std::vector<glm::vec2> uvs;

            std::vector<unsigned int> indicesCounts;
            std::vector<unsigned int> indices;

            std::vector<glm::mat4> inverseBindTransforms;//Position of joint
            std::vector<float> weightsArray;
            std::vector<unsigned int> weightCounts;
            std::vector<unsigned int> weightIndices;
            std::vector<glm::uvec3> jointIds;
            std::vector<glm::vec3> jointWeights;

            std::vector<JointHeirarchy> heirarchy;//Hierarchy of joints
            std::vector<unsigned int> currentPosition;//Current Position in hierarchy
            unsigned int newChildPosition = 0;//(one step more is stored for child which may be needed)
            bool heirarchyStarted = false;
            bool consecutiveNodes = false;
            std::string currentName;

            bool timeStepsLoaded = false;//To ensure that time steps are loaded only one
            std::vector<AnimationIO> jointDatas;//To store the different animation poses of different joints
            std::vector<float> timeSteps;//Stores the time steps in keyFrame

            if(stream == NULL){
                std::cout << "Warning::Cannot Read File:"<< colladaFile << std::endl;
            }

            //Reading the data from file to vectors
            while(getline(stream, line) != NULL){
                //Remove all white spaces before
                line = removeAllFirstCharacter(line);
                //Specifying the library type
                if(line.find("<library_geometries>") != std::string::npos){
                    libraryType = GEOMETRY;
                }
                else if(line.find("<library_animations>") != std::string::npos){
                    libraryType = ANIMATIONS;
                }
                else if(line.find("<library_controllers>") != std::string::npos){
                    libraryType = CONTROLLERS;
                }
                else if(line.find("<library_visual_scenes>") != std::string::npos){
                    libraryType = SCENES;
                }

                //If Geometry Library is selected and vertex data then
                //Parsing geometry data
                else if((line.find("float_array") != std::string::npos)
                        && (line.find("positions-array") != std::string::npos)
                        && (libraryType == GEOMETRY)){
                    //<float_array id="Cube-mesh-positions-array" count="2220">0.3735479
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[2], '"');
                    std::string num_data = temp[1];
                    unsigned int number;
                    {
                        std::stringstream num_ss(num_data);
                        num_ss >> number;
                    }

                    float position_array[3];
                    unsigned int array_pos;
                    //Reading first value
                    temp[2] = removeAllFirstCharacter(temp[2]);
                    {
                        std::stringstream num_ss(temp[2]);
                        num_ss >> position_array[0];
                        array_pos = 1;
                    }
                    for(unsigned int i=1; i<(number+1);i++){
                        //Loading the data to position vector
                        std::stringstream num_ss(datas[i+2]);
                        num_ss >> position_array[array_pos];
                        array_pos++;

                        if(array_pos >=3){
                            positions.push_back(glm::vec3(position_array[0], position_array[1], position_array[2]));
                            array_pos = 0;
                        }
                    }
                }
                else if((line.find("float_array") != std::string::npos)
                        && (line.find("normals-array") != std::string::npos)
                        && (libraryType == GEOMETRY)){
                    //<float_array id="Cube-mesh-normals-array" count="4224">0.2117975
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[2], '"');
                    std::string num_data = temp[1];
                    unsigned int number;
                    {
                        std::stringstream num_ss(num_data);
                        num_ss >> number;
                    }

                    float normal_array[3];
                    unsigned int array_pos;
                    //Reading first value
                    temp[2] = removeAllFirstCharacter(temp[2]);
                    {
                        std::stringstream num_ss(temp[2]);
                        num_ss >> normal_array[0];
                        array_pos = 1;
                    }
                    for(unsigned int i=1; i<(number+1);i++){
                        //Loading the data to normal vector
                        std::stringstream num_ss(datas[i+2]);
                        num_ss >> normal_array[array_pos];
                        array_pos++;

                        if(array_pos >=3){
                            normals.push_back(glm::vec3(normal_array[0], normal_array[1], normal_array[2]));
                            array_pos = 0;
                        }
                    }
                }
                else if((line.find("float_array") != std::string::npos)
                        && (line.find("map-0-array") != std::string::npos)
                        && (libraryType == GEOMETRY)){
                    //<float_array id="Cube-mesh-map-0-array" count="8520">0.7784072
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[2], '"');
                    std::string num_data = temp[1];
                    unsigned int number;
                    {
                        std::stringstream num_ss(num_data);
                        num_ss >> number;
                    }

                    float uv_array[2];
                    unsigned int array_pos;
                    //Reading first value
                    temp[2] = removeAllFirstCharacter(temp[2]);
                    {
                        std::stringstream num_ss(temp[2]);
                        num_ss >> uv_array[0];
                        array_pos = 1;
                    }
                    for(unsigned int i=1; i<(number+1);i++){
                        //Loading the data to uv vector
                        std::stringstream num_ss(datas[i+2]);
                        num_ss >> uv_array[array_pos];
                        array_pos++;

                        if(array_pos >=2){
                            uvs.push_back(glm::vec2(uv_array[0], uv_array[1]));
                            array_pos = 0;
                        }
                    }
                }
                else if((line.find("<vcount>") != std::string::npos)
                        && (libraryType == GEOMETRY)){
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[0], '>');
                    std::string num_data = temp[1];

                    unsigned int number;
                    //Reading first number
                    {
                        std::stringstream num_ss(num_data);
                        num_ss >> number;
                        indicesCounts.push_back(number);                }
                    for(unsigned int i=1; i<(datas.size()-1);i++){
                        //Loading the data to uv vector
                        std::stringstream num_ss(datas[i]);
                        num_ss >> number;
                        indicesCounts.push_back(number);
                    }
                }
                else if((line.find("<p>") != std::string::npos)
                        && (libraryType == GEOMETRY)){
                    //<p>97
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[0], '>');
                    std::string num_data = temp[1];

                    unsigned int number;
                    //Reading first number
                    {
                        std::stringstream num_ss(num_data);
                        num_ss >> number;
                        indices.push_back(number);
                    }
                    for(unsigned int i=1; i<datas.size();i++){
                        //Loading the data to uv vector
                        std::stringstream num_ss(datas[i]);
                        num_ss >> number;
                        indices.push_back(number);
                    }
                }

                //Parsing the animation data
                else if((line.find("float_array id=") != std::string::npos)
                        && (line.find("pose_matrix-input-array") != std::string::npos)
                        && (libraryType == ANIMATIONS)
                        && !timeStepsLoaded){
                    //<float_array id="Armature_Torso_pose_matrix-input-array" count="5">0 0.2083333 0.4166666 0.625 0.8333333</float_array>
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[2], '>');

                    std::stringstream ss_data(temp[1]);
                    float step;
                    ss_data>>step;
                    timeSteps.push_back(step);

                    for(unsigned int i=1; i<(datas.size()-2); i++){
                        std::stringstream ss_datum(datas[i+2]);
                        ss_datum>>step;
                        timeSteps.push_back(step);
                    }
                    timeStepsLoaded = true;
                }
                else if((line.find("float_array id=") != std::string::npos)
                        && (line.find("pose_matrix-output-array") != std::string::npos)
                        && (libraryType == ANIMATIONS)){
                    //<float_array id="Armature_Torso_pose_matrix-output-array" count="80">1 0 0 ....0 0 1</float_array>
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[2], '>');
                    std::stringstream ss_data(temp[1]);
                    float value;
                    ss_data>>value;
                    glm::mat4 currentPose;
                    currentPose[0][0] = value;

                    std::vector<glm::mat4> poses;
                    for(unsigned int i=1; i<(datas.size()-2); i++){
                        std::stringstream ss_datum(datas[i+2]);
                        ss_datum>>value;
                        unsigned int matPos = i%16;
                        unsigned int row = matPos%4;
                        unsigned int column = matPos/4;
                        currentPose[row][column] = value;

                        //If all value of matrix is loaded
                        if(matPos == 15){
                            poses.push_back(currentPose);
                            currentPose = glm::mat4(1.0);
                        }
                    }
                    AnimationIO tempAnimationIO;
                    tempAnimationIO.transforms = poses;
                    jointDatas.push_back(tempAnimationIO);
                }

                //Reading skeletal information
                //Reading the name of joints (its index will be id)

                //Reading Inverse Bind Transformation here
                else if((line.find("float_array") != std::string::npos)
                        && (line.find("poses-array") != std::string::npos)
                        && (libraryType == CONTROLLERS)){
                    //<float_array id="Armature_Cube-skin-bind_poses-array" count="256">1 0 0...
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[2], '>');
                    std::stringstream ss_firstData(temp[1]);
                    glm::mat4 eachInverseBind = glm::mat4(1.0);
                    float num;
                    ss_firstData>>num;
                    eachInverseBind[0][0] = num;

                    for(unsigned int i=1; i<(datas.size()-2); i++){
                        std::stringstream ss_data(datas[i+2]);
                        ss_data>>num;
                        unsigned int matPos = i%16;
                        unsigned int row = matPos%4;
                        unsigned int column = matPos/4;
                        eachInverseBind[row][column] = num;

                        //If all value of matrix is loaded
                        if(matPos == 15){
                            inverseBindTransforms.push_back(eachInverseBind);
                            eachInverseBind = glm::mat4(1.0);
                        }
                    }
                }
                else if((line.find("float_array") != std::string::npos)
                        && (line.find("weights-array") != std::string::npos)
                        && (libraryType == CONTROLLERS)){
                    //<float_array id="Armature_Cube-skin-weights-array" count="1393">1 1
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[2], '>');
                    std::stringstream ss_firstData(temp[1]);
                    float num;
                    ss_firstData>>num;
                    weightsArray.push_back(num);

                    for(unsigned int i=1; i<(datas.size()-2); i++){
                        std::stringstream ss_data(datas[i+2]);
                        ss_data>>num;
                        weightsArray.push_back(num);
                    }

                }
                else if((line.find("<vcount>") != std::string::npos)
                        && (libraryType == CONTROLLERS)){
                    //<vcount>1 1 1 1 1 .....  1 1 1 1 </vcount>
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[0], '>');
                    std::stringstream ss_firstData(temp[1]);
                    unsigned int num;
                    ss_firstData>>num;
                    weightCounts.push_back(num);

                    for(unsigned int i=1; i<(datas.size()-1); i++){
                        std::stringstream ss_data(datas[i]);
                        ss_data>>num;
                        weightCounts.push_back(num);
                    }

                }
                else if((line.find("<v>") != std::string::npos)
                        && (libraryType == CONTROLLERS)){
                    //<v>3 2.....1392</v>
                    std::vector<std::string> datas = splitString(line);
                    std::vector<std::string> temp = splitString(datas[0], '>');
                    std::stringstream ss_firstData(temp[1]);
                    unsigned int num;
                    ss_firstData>>num;
                    weightIndices.push_back(num);

                    for(unsigned int i=1; i<(datas.size()); i++){
                        std::stringstream ss_data(datas[i]);
                        ss_data>>num;
                        weightIndices.push_back(num);
                    }

                }


                //Make sure that its inverse bind matrix is calculated properly
                else if((line.find("<node id=\"Armature\"") != std::string::npos)
                        && (libraryType == SCENES)){
                            heirarchyStarted = true;
                }
                else if((line.find("<node id=") != std::string::npos)
                        && (libraryType == SCENES)
                        && heirarchyStarted){
                        //<node id="Torso" name="Torso" sid="Torso" type="JOINT">
                        std::vector<std::string> datas = splitString(line);
                        std::vector<std::string> temp = splitString(datas[2], '"');
                        currentName = temp[1];

                        if(consecutiveNodes)
                            currentPosition.push_back(0);
                        else
                            currentPosition.push_back(newChildPosition);
                        consecutiveNodes = true;
                }
                else if((line.find("matrix sid=\"transform\"") != std::string::npos)
                        && (libraryType == SCENES)
                        && heirarchyStarted){
                        JointHeirarchy tempHeirarchy;
                        tempHeirarchy.name = currentName;
                        tempHeirarchy.position = currentPosition;
                        heirarchy.push_back(tempHeirarchy);
                }
                else if((line.find("</node>") != std::string::npos)
                        && (libraryType == SCENES)
                        && heirarchyStarted){
                        if(currentPosition.size()<1){
                            newChildPosition = 0;
                            continue;
                        }
                        unsigned int lastPosition = currentPosition.size()-1;
                        newChildPosition = currentPosition[lastPosition]+1;
                        currentPosition.pop_back();
                        consecutiveNodes = false;
                }
            }

            //Storing the weights and ids in vertex position manner
            for(unsigned int i=0,j=0; i<weightCounts.size(); i++){
                //i = position of weight index count
                //j = position of weight and id
                std::vector<float> temp_weights;
                std::vector<unsigned int> temp_weightIDs;
                glm::vec3 weights = glm::vec3(0.0);//Dominating weights of vertex
                glm::uvec3 ids = glm::uvec3(0);//Dominating ids of weights

                unsigned int weight_count = weightCounts[i];//Weight count of current vertex
                //Storing the all weights and ids corresponding to vertex
    //            for(unsigned int k=0; k<weight_count&&k<3; k++){
    //                ids[k] = weightIndices[2*k+j];
    //                weights[k] = weightIndices[2*k+j+1];
    //            }

                for(unsigned int k=0; k<weight_count; k++){
                    temp_weightIDs.push_back(weightIndices[2*k+j]);
                    temp_weights.push_back(weightsArray[weightIndices[2*k+j+1]]);
                }

                //Searching for dominating weights in that array
                for(unsigned int k=0; k<temp_weights.size(); k++){
                    unsigned int temp_id = temp_weightIDs[k];
                    float temp_weight = temp_weights[k];

                    //Putting weights in descending order
                    //Selecting 3 major weights
                    if(temp_weight>weights[0]){
                        weights[2] = weights[1];
                        weights[1] = weights[0];
                        weights[0] = temp_weight;

                        ids[2] = ids[1];
                        ids[1] = ids[0];
                        ids[0] = temp_id;
                    }
                    else if(temp_weight>weights[1]){
                        weights[2] = weights[1];
                        weights[1] = temp_weight;

                        ids[2] = ids[1];
                        ids[1] = temp_id;
                    }
                    else if(temp_weight>weights[2]){
                        weights[2] = temp_weight;
                        ids[2] = temp_id;
                    }
                }

                //Normalizing the weights values
                float sumWeights = weights.x+weights.y+weights.z;
                weights = weights/sumWeights;
                jointWeights.push_back(weights);
                jointIds.push_back(ids);
                j+= 2*weight_count;

            }

//            std::cout<<"Data Loaded"<<std::endl;
//            std::cout<<"Positions = "<< positions.size()<<std::endl;
//            std::cout<<"Normals = "<< normals.size()<<std::endl;
//            std::cout<<"Uvs = "<< uvs.size() <<std::endl;
//            std::cout<<"Indices = "<< indices.size() <<std::endl;
//            std::cout<<"Indices Counts = "<< indicesCounts.size() <<std::endl;
//            std::cout<<"Joints found = " << jointNames.size() <<std::endl;
//            std::cout<<"Joints weights found = " << weightsArray.size() <<std::endl;
//            std::cout<<"Joints weights Counts found = " << weightCounts.size() <<std::endl;
//            std::cout<<"Joints weights Indices found = " << weightIndices.size() <<std::endl;
//            std::cout<<"Weights and id of "<<jointWeights.size()<<" vertex found"<<std::endl;

            //Processing skin data
            {
                 //If counts are cont defined, takes as triangle face as default
                if(indicesCounts.size() == 0){
                    for(unsigned int j=0; j<indices.size(); j+=4*3){
                        //i = position of index count
                        //j = position of index
                        AnimationData VAOdata;

                        //Loading the data of each faces
                        //Using only 3 vertices to make faces
                        for(unsigned int k=0; k<3; k++){
                            unsigned int position_index = indices[4*k+j];
                            VAOdata.position =  positions[position_index];
                            VAOdata.normals =   normals[indices[4*k+j+1]];
                            VAOdata.uvs =       uvs[indices[4*k+j+2]];
                            VAOdata.joints =    jointIds[position_index];
                            VAOdata.weights =   jointWeights[position_index];

                            vertices.push_back(VAOdata);
                        }
                    }
                }
                //Takes the face count but uses first 3 vertices to make triangle
                else{
                    for(unsigned int i=0,j=0; i<indicesCounts.size(); i++){
                        //i = position of index count
                        //j = position of index
                        AnimationData VAOdata;

                        //Loading the data of each faces
                        //Using only 3 vertices to make faces
                        for(unsigned int k=0; k<3; k++){
                            unsigned int position_index = indices[4*k+j];
                            VAOdata.position =  positions[position_index];
                            VAOdata.normals =   normals[indices[4*k+j+1]];
                            VAOdata.uvs =       uvs[indices[4*k+j+2]];
                            VAOdata.joints =    jointIds[position_index];
                            VAOdata.weights =   jointWeights[position_index];

                            vertices.push_back(VAOdata);
                        }
                        j+=4*indicesCounts[i];
                    }
                }
            }

//            std::cout<<"Skin data loaded"<<std::endl;

            unsigned int max_level = 0;//Finds maximum level of hierarchy
            //Finding the level of root
            for(unsigned int i=0; i<heirarchy.size(); i++){
                if(max_level < heirarchy[i].position.size())
                    max_level = heirarchy[i].position.size();
            }

            std::vector<Joint> parents;
            std::vector<Joint> children;
            std::vector<unsigned int> parentIndex;//Index of parents in hierarchy
            std::vector<unsigned int> childIndex;//Index of child in hierarchy

            //First load data of last level children
             for(unsigned int j=0; j<heirarchy.size(); j++){
                 if(heirarchy[j].position.size() == max_level){
                     std::string name = heirarchy[j].name;
                     //Searching for id of joint
                     Joint tempJoint;
                     tempJoint.name = name;
                     tempJoint.id = j;
                     tempJoint.invertedBindTransform = inverseBindTransforms[j];
                     children.push_back(tempJoint);
                     childIndex.push_back(j);
                 }
             }

            //Then use child to push on parent and pass that as a children for next iteration
            for(unsigned int i=max_level; i>=2; i--){
                //Searching for parent
                for(unsigned int j=0; j<heirarchy.size(); j++){
                    if(heirarchy[j].position.size() == (i-1)){
                        std::string name = heirarchy[j].name;
                        Joint tempJoint;
                        tempJoint.name = name;
                        tempJoint.id = j;
                        tempJoint.invertedBindTransform = inverseBindTransforms[j];
                        parents.push_back(tempJoint);
                        parentIndex.push_back(j);
                    }
                }

                //Find out the corresponding parents of the children
                for(unsigned int j=0; j<children.size(); j++){
                    JointHeirarchy childHeirarchy = heirarchy[childIndex[j]];
                    //Check for each parent if it is parent
                    for(unsigned int l=0; l<parents.size(); l++){
                        JointHeirarchy parentHeirarchy = heirarchy[parentIndex[l]];
                        bool isParent = true;
                        //Matching each step with parent
                        for(unsigned int m=0; m<parentHeirarchy.position.size(); m++){
                            if(parentHeirarchy.position[m] != childHeirarchy.position[m]){
                                isParent = false;
                                break;
                            }
                        }
                        if(isParent){
                            //If j-th child is the corresponding child of l-th parent
                            parents[l].addChild(children[j]);
                            break;
                        }
                    }
                }

                children.clear();
                childIndex.clear();
                //Making the parents children for next iteration
                children = parents;
                childIndex = parentIndex;
                parents.clear();
                parentIndex.clear();
            }
            //Assigning to root joint after its all done
            rootJoint = children[0];
            children.clear();
            childIndex.clear();
            parents.clear();
            parentIndex.clear();

//            std::cout<<"Skeletal data loaded"<<std::endl;

            //Process the animation data into animation
            Animation animation;
            std::vector<KeyFrame> frames;
            float length;

            for(unsigned int i=0; i<jointDatas[0].transforms.size(); i++){
                //i=transformation of each joints
                //j=each joints
                KeyFrame frame;
                float timeStamp;
                for(unsigned int j=0; j<jointDatas.size(); j++){
                    glm::mat4 pose = jointDatas[j].transforms[i];
                    JointTransform jointTransform = JointTransform::loadFromMatrix(pose);
                    frame.addJointTransforms(jointTransform, j);
                }
                length = timeSteps[i];
                frame.timeStamp = length;
                frames.push_back(frame);
                frame.jointTransforms.flushValues();
            }
            animation.keyFrames = frames;
            animation.length = length;
            animator.setAnimation(animation);

//            std::cout<<"Animation Data Loaded"<<std::endl;

            vb.loadData(&vertices[0], sizeof(AnimationData)*vertices.size());
            vertexCount = vertices.size();

            vertices.clear();
            positions.clear();
            normals.clear();
            uvs.clear();
            indicesCounts.clear();
            indices.clear();

            inverseBindTransforms.clear();
            weightsArray.clear();
            weightCounts.clear();
            weightIndices.clear();
            jointWeights.clear();
            jointIds.clear();

            heirarchy.clear();
            currentPosition.clear();
            jointDatas.clear();
            timeSteps.clear();
        }

        void putTransforms(std::vector<glm::mat4>& container, Joint& joint){
            //Put transformation of joint in container
            container.push_back(joint.animatedTransform);
            for(unsigned int i=0; i<joint.children.size(); i++){
                putTransforms(container, joint.children[i]);
            }
        }

    public:

        void load(std::string colladaFile, std::string textureLocation){
            //Parse collada into buffer
            parseCollada(colladaFile);
            OpenGL::VertexBufferLayout layout;
            layout.pushFloat(3);//Position
            layout.pushFloat(3);//Normal
            layout.pushFloat(2);//UV
            layout.pushUnsignedInt(3);//Joint IDs
            layout.pushFloat(3);//Joint Weights
            va.generateVertexArray();
            va.addBuffer(vb, layout);

            this->texture.loadTexture(textureLocation);
        }

        static void loadShader(std::string shaderLocation){
            shader.loadShader(shaderLocation);
        }

        void cleanUP(){
            va.deleteVertexArray();
            vb.deleteVertexBuffer();
            texture.deleteTexture();
        }

        void update(int fps){
            animator.animate(fps, rootJoint);
            transformations.clear();
            putTransforms(transformations, rootJoint);
            shader.bind();
            shader.addUniformMat4fv("u_jointTransforms", &transformations[0][0][0], transformations.size());
        }

        void draw(glm::mat4 mvp){
            shader.bind();
            shader.addUniformMat4f("u_viewProjection", mvp);
            shader.addUniform1i("u_slot", 0);
            va.bind();
            texture.bind();
            GLCall(glDrawArrays(GL_TRIANGLES, 0, vertexCount));
        }

        static void deleteShader(){
            shader.deleteShader();
        }
    };

};

class Player{
private:
    glm::vec3 position;
    float y_rotation;
    const float velocity = 0.20f;
    ObjMesh body;
    OpenGL::Texture texture;

public:
    void setPosition(glm::vec3 pos){
        position = pos;
    }

    void setDirection(float rot){
        y_rotation = rot;
    }

    glm::vec3 getFocusPosition(){
        glm::vec3 focus = position;
        focus.x -= 0.225*sin(glm::radians(y_rotation));
        focus.z -= 0.225*cos(glm::radians(y_rotation));
        focus.y += 1.3;
        return focus;
    }

    glm::vec3 getPosition(){
        return position;
    }

    float getRotation(){
        return y_rotation;
    }

    void loadFiles(std::string objPath, std::string texturePath, float scaling = 1){
        body.loadFile(objPath, scaling);
        texture.loadTexture(texturePath);
    }

    void moveForward(Terrain terrain){
        position -= glm::vec3(velocity*sin(glm::radians(y_rotation)), 0.0, velocity*cos(glm::radians(y_rotation)));
        position.y = terrain.getHeightAt(position.x, position.z);
    }

    void moveBackward(Terrain terrain){
        position += glm::vec3(velocity*sin(glm::radians(y_rotation)), 0.0, velocity*cos(glm::radians(y_rotation)));
        position.y = terrain.getHeightAt(position.x, position.z);
    }

    void moveRight(Terrain terrain){
        y_rotation -= 90;
        moveForward(terrain);
        y_rotation += 90;
    }

    void moveLeft(Terrain terrain){
        y_rotation += 90;
        moveForward(terrain);
        y_rotation -= 90;
    }

    void draw(OpenGL::Shader shader){
        shader.bind();
        texture.bind();
        body.bindArray();
        GLCall(glDrawArrays(GL_TRIANGLES, 0, body.getVertexCount()));
    }

    void cleanUP(){
        body.cleanUP();
        texture.deleteTexture();
    }
};

class Camera{
private:
    glm::vec3 position;
    glm::vec3 camDirection;
    float yaw = 0.0;
    float pitch = 15.0;
    float roll = 0.0;
    const float sensitivity = 0.125f;
    const float MAX_DISTANCE = 4.0f;
    //const float MAX_DISTANCE = 20.0f;
    const float MIN_DISTANCE = 0.0f;
    float distance = MAX_DISTANCE;

    void limitAngleToPositive(float& angle){
        if(angle>360)
            angle -= 360;
        if(angle<0)
            angle +=360;
    }

    void recalculateDistance(){
        if(pitch >=0)
            distance = MAX_DISTANCE;
        else{
            float slope = (MAX_DISTANCE - MIN_DISTANCE)/89.0;
            distance = slope * pitch + MAX_DISTANCE;
        }
    }

public:
    void setYaw(float yaw){
        this->yaw = yaw;
    }

    void setPitch(float pitch){
        this->pitch = pitch;
    }

    void increaseYaw(float delta = 1){
        yaw += sensitivity*delta;
        limitAngleToPositive(yaw);
    }

    void increasePitch(float delta = 1){
        pitch += sensitivity*delta;
        if(pitch > 75)
            pitch = 75;
        else if(pitch < -80)
            pitch = -80;

        recalculateDistance();
    }

    float getNewPlayerRotation(Player player){
        float result = player.getRotation()+yaw;
        limitAngleToPositive(result);
        yaw = 0;
        return result;
    }

    void setPosition(glm::vec3 pos){
        position = pos;
    }

    glm::vec3 getPosition(){
        return position;
    }

    glm::vec3 getDirection(){
        return camDirection;
    }

    void follow(Player player){
        glm::vec3 playerPos = player.getFocusPosition();
        float horizontal = distance*cos(glm::radians(pitch));
        float vertical = distance*sin(glm::radians(pitch));
        float theta = player.getRotation() + yaw;
        float x_offset = horizontal*sin(glm::radians(theta));
        float z_offset = horizontal*cos(glm::radians(theta));

        position.x = playerPos.x + x_offset;
        position.y = playerPos.y + vertical;
        position.z = playerPos.z + z_offset;

        camDirection = glm::vec3(x_offset, vertical, z_offset);
        camDirection = glm::normalize(camDirection);
    }

    glm::mat4 getViewMatrix(){
        glm::vec3 camRight = glm::normalize(glm::cross(glm::vec3(0.0, 1.0, 0.0), camDirection));
        glm::vec3 camUp = glm::cross(camDirection, camRight);

        glm::vec2 translation = glm::normalize(glm::vec2(camDirection.z, -camDirection.x));
        translation *= 0.45;
        position = position + glm::vec3(translation.x, 0.0, translation.y);

        glm::mat4 first = glm::transpose(glm::mat4( glm::vec4(camRight, 0.0),
                                                    glm::vec4(camUp, 0.0),
                                                    glm::vec4(camDirection, 0.0),
                                                    glm::vec4(glm::vec3(0.0), 1.0)));
        glm::mat4 second = glm::mat4(1.0);
        second[3] = glm::vec4(-position, 1.0);

        /*
        view  = |  Rx Ry  Rz  0.0 |   | 1.0 0.0 0.0 -Px |
                |  Ux Uy  Uz  0.0 | * | 0.0 1.0 0.0 -Py |
                |  Dx Dy  Dz  0.0 |   | 0.0 0.0 1.0 -Pz |
                |  0  0   0   1.0 |   | 0.0 0.0 0.0 1.0 |
        */
        return first*second;
    }

    void invertPitch(){
        pitch *= -1;
    }

};

class FPSManager{
private:
    int targetFPS;
    int countedFPS;
    double initial_time;
    double final_time;
public:
    FPSManager(int targetFPS){
        this->targetFPS = targetFPS;
        this->countedFPS = targetFPS;
    }

    /**
    *Sets the FPS to be limited
    */
    void setTargetFPS(int targetFPS){
        this->targetFPS = targetFPS;
        this->countedFPS = targetFPS;
    }

    /**
    *Updates the counting of fps and can display too
    */
    void updateCounter(bool displayFPS=false){
        static int frameCount = 0;
        static double lastCountTime = glutGet(GLUT_ELAPSED_TIME);
        float timefromLastCount = glutGet(GLUT_ELAPSED_TIME)-lastCountTime;
        //If more than one second is elapsed
        if( timefromLastCount >= 1000.0){
            countedFPS = frameCount;
            //Resets frame counter and sets time reference for time count
            frameCount = 0;
            lastCountTime = glutGet(GLUT_ELAPSED_TIME);

            if(displayFPS){
                std::cout<<"Counted FPS = "<<countedFPS<<std::endl;
            }
        }
        frameCount++;
    }

    /**
    *Initiate at the starting of display
    *Necessary to limit FPS
    */
    void initiateTimer(){
        initial_time = glutGet(GLUT_ELAPSED_TIME);
    }

    /**
    *Timer should have been initiated for this to work
    */
    void limitFPS(bool useCountedFPS=true, bool showWarning=true){
        //Limiting FPS
//        float targetTime = 1000.0/float(targetFPS);
//        int frame_lag_in_second = targetFPS - countedFPS;
//        float time_per_frame = 2000.0/float(targetFPS+countedFPS);
//        float frame_lag_per_frame = frame_lag_in_second*time_per_frame/1000.0;
//        float time_lag_per_frame = useCountedFPS?(frame_lag_per_frame*time_per_frame):0;

        float offset = 0.95;
        float targetTime = 1000.0/float(targetFPS);
        int frame_lag_in_second = targetFPS - countedFPS;
        float time_lag_per_frame = useCountedFPS?(offset+2.0*float(frame_lag_in_second)/float(targetFPS+countedFPS)):0;

        final_time = glutGet(GLUT_ELAPSED_TIME);
        double delay_time =  targetTime - (final_time-initial_time) - time_lag_per_frame;
        if(delay_time > 0)   Sleep(delay_time);
        else if(showWarning) std::cout<<"Warning: FPS lagging this frame!!!"<<std::endl;
    }

    /**
    *Returns the counted FPS
    */
    int getCountedFPS(){
        return countedFPS;
    }
};

class GUI{
private:
    static OpenGL::Shader shader;
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    OpenGL::IndexBuffer ib;
    OpenGL::Texture texture;


public:
    void load(glm::vec2 position,glm::vec2 size, std::string textureLocation){
        float positions[] = {
            position.x - size.x/2, position.y - size.y/2, 0, 0,
            position.x + size.x/2, position.y - size.y/2, 1, 0,
            position.x + size.x/2, position.y + size.y/2, 1, 1,
            position.x - size.x/2, position.y + size.y/2, 0, 1
        };

        unsigned int indices[] = {
            0, 1, 2,
            2, 3, 0
        };

        vb.loadData(positions, 4*4*sizeof(float));
        OpenGL::VertexBufferLayout layout;
        layout.pushFloat(2);
        layout.pushFloat(2);
        va.generateVertexArray();
        va.addBuffer(vb, layout);
        ib.loadData(indices, 6);

        texture.loadTexture(textureLocation, false, 0);
    }

    static void specifyShader(std::string shaderLocation){
        GUI::shader.loadShader(shaderLocation);
    }

    static void deleteShader(){
        GUI::shader.deleteShader();
    }

    void draw(){
        texture.bind();
        GUI::shader.bind();
        GUI::shader.addUniform1i("u_slot", 0);
        va.bind();
        ib.bind();
        GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, NULL));
    }

    void cleanUP(){
        va.deleteVertexArray();
        ib.deleteIndexBuffer();
        vb.deleteVertexBuffer();
        texture.deleteTexture();
    }
};

struct PosUV{
    glm::vec3 position;
    glm::vec2 uv;
};

/**
*Logic:
*      -Render the scene above the water level and flip it for reflection
*      -Render the scene below the water level for refraction
*      -Use dudv maps to distort combined texture and also make distortion vary with time
*      -Use normal maps to vary its lighting behaviour
*      -And thats all!!!
*/
class Water{
private:
    OpenGL::FrameBuffer reflectionFrame;
    OpenGL::FrameBuffer refractionFrame;
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    OpenGL::IndexBuffer ib;
    OpenGL::Texture reflectionTexture;
    OpenGL::Texture refractionTexture;
    OpenGL::Texture dudv;
    OpenGL::Texture normal;
    OpenGL::Texture depth;
    static OpenGL::Shader waterShader;
    int width,height;
    const float waveSpeed = 0.005;
    float moveFactor = 0.0;
    float waterLevel;

public:
    void loadData(glm::vec3 position, glm::vec2 size,int width,int height,int screenWidth,int screenHeight,
                  std::string dudvLoacation, std::string normalMapLocation){
        this->width = width;
        this->height = height;
        this->waterLevel = position.y;

        std::vector<PosUV> vertices;
        vertices.push_back({glm::vec3(position.x-size.x, position.y, position.z+size.y), glm::vec2(0, 0)});
        vertices.push_back({glm::vec3(position.x+size.x, position.y, position.z+size.y), glm::vec2(1, 0)});
        vertices.push_back({glm::vec3(position.x+size.x, position.y, position.z-size.y), glm::vec2(1, 1)});
        vertices.push_back({glm::vec3(position.x-size.x, position.y, position.z-size.y), glm::vec2(0, 1)});

        std::vector<unsigned int> indices;
        indices.push_back(0);
        indices.push_back(1);
        indices.push_back(2);
        indices.push_back(2);
        indices.push_back(3);
        indices.push_back(0);

        va.generateVertexArray();
        vb.loadData(&vertices[0], sizeof(PosUV)*vertices.size());
        OpenGL::VertexBufferLayout layout;
        layout.pushFloat(3);
        layout.pushFloat(2);
        va.addBuffer(vb, layout);
        ib.loadData(&indices[0], indices.size());
        vertices.clear();
        indices.clear();

        reflectionFrame.generateFrameBuffer();
        reflectionFrame.bind(width, height);
        reflectionTexture.loadCreatedTexture(reflectionFrame.AttachColorTexture(width, height));

        refractionFrame.generateFrameBuffer();
        refractionFrame.bind(width, height);
        refractionTexture.loadCreatedTexture(refractionFrame.AttachColorTexture(width, height));
        depth.loadCreatedTexture(refractionFrame.AttachDepthTexture(width, height));

        refractionFrame.unbind(screenWidth, screenHeight);
        dudv.loadTexture(dudvLoacation);
        normal.loadTexture(normalMapLocation);
    }

    static void loadShader(std::string filePath, glm::vec3 lightColor, glm::vec3 lightDirection, float cameraNear, float cameraFar){
        Water::waterShader.loadShader(filePath);
        Water::waterShader.bind();
        Water::waterShader.addUniform1i("u_reflectionSampler", 0);
        Water::waterShader.addUniform1i("u_refractionSampler", 1);
        Water::waterShader.addUniform1i("u_dudvSampler", 2);
        Water::waterShader.addUniform1i("u_normalSampler", 3);
        Water::waterShader.addUniform1i("u_depthSampler", 4);

        float color[] = {lightColor.x, lightColor.y, lightColor.z};
        lightDirection = glm::normalize(lightDirection);
        float direction[] = {lightDirection.x, lightDirection.y, lightDirection.z};

        Water::waterShader.addUniform3f("u_lightColor", color);
        Water::waterShader.addUniform3f("u_lightDirection", direction);
        Water::waterShader.addUniform1f("near", cameraNear);
        Water::waterShader.addUniform1f("far", cameraFar);
    }

    void startReflectionTexture(){
        reflectionFrame.bind(width, height);
    }

    void stopTexture(int screenWidth, int screenHeight){
        reflectionFrame.unbind(screenWidth, screenHeight);
    }

    void startRefractionTexture(){
        refractionFrame.bind(width, height);
    }

    float getWaterLevel(){
        return waterLevel;
    }

    /**
    *Don't use draw function when reflection texture is not stopped
    */
    void draw(glm::mat4 model, glm::mat4 view, glm::mat4 projection, glm::vec3 viewPosition, int fps){
        Window::enableAlphaBlending();
        moveFactor += waveSpeed/(float)fps;
        if(moveFactor > 1)
            moveFactor = 0;

        float view_pos[]= {viewPosition.x, viewPosition.y, viewPosition.z};

        Water::waterShader.bind();
        Water::waterShader.addUniformMat4f("u_model", model);
        Water::waterShader.addUniformMat4f("u_view", view);
        Water::waterShader.addUniformMat4f("u_projection", projection);
        Water::waterShader.addUniform1f("u_moveFactor", moveFactor);
        Water::waterShader.addUniform3f("u_viewPos", view_pos);

        reflectionTexture.bind(0);
        refractionTexture.bind(1);
        dudv.bind(2);
        normal.bind(3);
        depth.bind(4);
        va.bind();
        ib.bind();
        GLCall(glDrawElements(GL_TRIANGLES, ib.getCount(), GL_UNSIGNED_INT, NULL));
        Window::disableBlending();
    }

    void cleanUP(){
        reflectionTexture.deleteTexture();
        refractionTexture.deleteTexture();
        reflectionFrame.deleteBuffer();
        refractionFrame.deleteBuffer();
        va.deleteVertexArray();
        vb.deleteVertexBuffer();
        ib.deleteIndexBuffer();
    }

    static void deleteShader(){
        Water::waterShader.deleteShader();
    }


};

class Billboard{
private:
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    OpenGL::IndexBuffer ib;
    glm::vec3 position;
    glm::vec2 size;
    static OpenGL::Shader shader;

    /**
    *Calculate the positions of quads to make sure they are always facing directly to camera
    */
    void calculateVertices(glm::mat4 view){
        glm::vec3 cameraRight = glm::vec3(view[0][0], view[1][0], view[2][0]);
        glm::vec3 cameraUp = glm::vec3(view[0][1], view[1][1], view[2][1]);
        std::vector<PosUV> vertices;
        const float squareVertices[] = {
             -0.5f, -0.5f,
              0.5f, -0.5f,
              0.5f,  0.5f,
             -0.5f,  0.5f
         };
         vertices.push_back({position+cameraRight*squareVertices[0]*size.x +cameraUp*squareVertices[1]*size.y, glm::vec2(0, 0)});
         vertices.push_back({position+cameraRight*squareVertices[2]*size.x +cameraUp*squareVertices[3]*size.y, glm::vec2(1, 0)});
         vertices.push_back({position+cameraRight*squareVertices[4]*size.x +cameraUp*squareVertices[5]*size.y, glm::vec2(1, 1)});
         vertices.push_back({position+cameraRight*squareVertices[6]*size.x +cameraUp*squareVertices[7]*size.y, glm::vec2(0, 1)});
         vb.feedDatatoAllocated(&vertices[0], 4*sizeof(PosUV));
         vertices.clear();
    }

public:
    void loadData(glm::vec3 position, glm::vec2 size){
        this->position = position;
        this->size = size;
        vb.allocateDynamically(4*sizeof(PosUV));
        va.generateVertexArray();
        OpenGL::VertexBufferLayout layout;
        layout.pushFloat(3);
        layout.pushFloat(2);
        va.addBuffer(vb, layout);
        unsigned int indices[] ={0, 1, 2, 2, 3, 0};
        ib.loadData(indices, 6);
    }

    void setPosition(glm::vec3 position){
        this->position = position;
    }

    void setSize(glm::vec2 size){
        this->size = size;
    }

    static void specifyShader(std::string shaderLocation){
        shader.loadShader(shaderLocation);
    }

    void draw(glm::mat4 view, glm::mat4 projection){
        calculateVertices(view);
        va.bind();
        ib.bind();
        shader.bind();
        shader.addUniformMat4f("u_view", view);
        shader.addUniformMat4f("u_projection", projection);
        GLCall(glDrawElements(GL_TRIANGLES, ib.getCount() , GL_UNSIGNED_INT, NULL));
    }
};

struct ParticleData{
    glm::vec3 position;
    glm::vec2 uv;
};

struct Particle{
    glm::vec3 position;
    glm::vec3 velocity;
    float elapsedTime;
    static glm::vec2 size;
    static float lifeTime;

    Particle():elapsedTime(0){}

    /**
    *Updates particles and returns true if particle is still alive
    */
    bool update(float gravity, int fps){
        velocity.y -= gravity/(float)fps;
        position = position + (1/(float)fps)*velocity;
        elapsedTime += 1/(float)fps;
        return elapsedTime<lifeTime;
    }

    /**
    *Takes the view matrix and returns the
    */
    std::vector<ParticleData> calculateVertices(glm::mat4 view, int grid_x, int grid_y){
        glm::vec3 cameraRight = glm::vec3(view[0][0], view[1][0], view[2][0]);
        glm::vec3 cameraUp = glm::vec3(view[0][1], view[1][1], view[2][1]);
        std::vector<ParticleData> vertices;

        int totalGrid = grid_x*grid_y;
        float pos_x = elapsedTime*totalGrid/lifeTime;
        int pos_y = grid_y-1;
        while(pos_x >= grid_x){
            pos_x -= grid_x;
            pos_y --;
        }
        pos_x =  int(pos_x);

        const float squareVertices[] = {
             -0.5f, -0.5f,
              0.5f, -0.5f,
              0.5f,  0.5f,
             -0.5f,  0.5f
         };
         vertices.push_back({position+cameraRight*squareVertices[0]*size.x +cameraUp*squareVertices[1]*size.y, glm::vec2(   (float)pos_x/grid_x,       (float)pos_y/grid_y)});
         vertices.push_back({position+cameraRight*squareVertices[2]*size.x +cameraUp*squareVertices[3]*size.y, glm::vec2(   (float)(pos_x+1)/grid_x,   (float)pos_y/grid_y)});
         vertices.push_back({position+cameraRight*squareVertices[4]*size.x +cameraUp*squareVertices[5]*size.y, glm::vec2(   (float)(pos_x+1)/grid_x,   (float)(pos_y+1)/grid_y)});
         vertices.push_back({position+cameraRight*squareVertices[6]*size.x +cameraUp*squareVertices[7]*size.y, glm::vec2(   (float)pos_x/grid_x,       (float)(pos_y+1)/grid_y)});
         return vertices;
    }
};

class ParticlesSystem{
private:
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    OpenGL::IndexBuffer ib;
    unsigned int indices_num;
    glm::vec3 emitter_position;
    std::vector<Particle> particles;
    float vertical_angle;
    float emission_radius;
    float velocity_magnetude;
    int gridSizeX,gridSizeY;
    static OpenGL::Shader shader;
    OpenGL::Texture texture;

    /**
    *After all particles are pushed, it calculate the respective indices for vertex buffer
    */
    void calculateIndices(){
        std::vector<unsigned int> indices;
        for(unsigned int i=0; i<particles.size(); i++){
            indices.push_back(4*i+0);
            indices.push_back(4*i+1);
            indices.push_back(4*i+2);
            indices.push_back(4*i+2);
            indices.push_back(4*i+3);
            indices.push_back(4*i+0);
        }
        ib.loadData(&indices[0], indices.size());
        indices.clear();
    }

    /**
    *Loads the data to vertex buffer using each particles data
    */
    void loadVertices(glm::mat4 view){
        std::vector<ParticleData> vertices;
        std::vector<ParticleData> temp_vertices;
        for(unsigned int i=0;i<particles.size(); i++){
            temp_vertices = particles[i].calculateVertices(view, gridSizeX, gridSizeY);
            for(int j=0; j<4; j++){
                vertices.push_back(temp_vertices[j]);
            }
            temp_vertices.clear();
        }
        vb.feedDatatoAllocated(&vertices[0], vertices.size()*sizeof(ParticleData));
        vertices.clear();
    }

    void initiateVertices(glm::vec2 size, float lifeTime,
                          unsigned int num_particles, float velocity){
        srand(time(NULL));
        Particle::size = size;
        Particle::lifeTime = lifeTime;
        velocity_magnetude = velocity;
        for(unsigned int i=0; i<num_particles; i++){
            float horizontal_angle = rand()%360;
            float t_vertical_angle = rand()%(int)vertical_angle;
            glm::vec3 vec_velocity = glm::vec3(
                                     sin(glm::radians(t_vertical_angle))*cos(glm::radians(horizontal_angle)),
                                     cos(glm::radians(t_vertical_angle)),
                                     sin(glm::radians(t_vertical_angle))*sin(glm::radians(horizontal_angle))
                                     );

            glm::vec3 del_pos = glm::vec3(emission_radius*cos(glm::radians(horizontal_angle)), 0,
                                    emission_radius*sin(glm::radians(horizontal_angle)));
            Particle particle;
            particle.position = emitter_position + del_pos;
            particle.velocity = velocity_magnetude * vec_velocity;
            particle.elapsedTime = i*lifeTime/num_particles;
            particles.push_back(particle);
        }
    }

    /**
    *Resets the position of particle but position relative to emitter position
    */
    void respawnParticle(int index){
        float horizontal_angle = rand()%360;
        float t_vertical_angle = rand()%(int)vertical_angle;
        glm::vec3 vec_velocity = glm::vec3(
                                 sin(glm::radians(t_vertical_angle))*cos(glm::radians(horizontal_angle)),
                                 cos(glm::radians(t_vertical_angle)),
                                 sin(glm::radians(t_vertical_angle))*sin(glm::radians(horizontal_angle))
                                 );
        glm::vec3 del_pos = glm::vec3(emission_radius*cos(glm::radians(horizontal_angle)), 0,
                                      emission_radius*sin(glm::radians(horizontal_angle)));
        particles[index].elapsedTime = 0;
        particles[index].position = emitter_position+del_pos;
        particles[index].velocity = velocity_magnetude * vec_velocity;
    }

    /**
    *After all particles are installed, it loads that datas to buffer
    */
    void loadToBuffer(){
        vb.allocateDynamically(particles.size()*4*sizeof(ParticleData));
        va.generateVertexArray();
        OpenGL::VertexBufferLayout vbl;
        vbl.pushFloat(3);
        vbl.pushFloat(2);
        va.addBuffer(vb, vbl);
        calculateIndices();
    }

public:
    /**
    *loads texture texture atlases to the particle
    *Atlases should be of square grid
    */
    void loadTexture(std::string textureLocation, int XgridSize, int YgridSize){
        gridSizeX = XgridSize;
        gridSizeY = YgridSize;
        texture.loadTexture(textureLocation);
    }

    /**
    *Sets the position of emitter, all particles will be spawn from relative to this position
    */
    void setParticles(glm::vec3 emitter_position = glm::vec3(0,0,0), float emission_radius = 0.5,unsigned int num_particles = 30, float velocity = 0.5,
                        float vertical_angle = 15,glm::vec2 size = glm::vec2(0.1, 0.1), float lifeTime = 2.0){
        this->emitter_position = emitter_position;
        this->emission_radius = emission_radius;
        this->vertical_angle = vertical_angle>0?vertical_angle:1;
        initiateVertices(size, lifeTime, num_particles, velocity);
        loadToBuffer();
    }

    /**
    *Sets the current emitter location
    */
    void setEmitterLocation(glm::vec3 position){
        this->emitter_position = position;
    }

    /**
    *Specifies the shader file to all particles system
    */
    static void specifyShader(std::string shaderLocation){
        shader.loadShader(shaderLocation);
        shader.bind();
        shader.addUniform1i("u_slot", 0);
    }

    /**
    *Updates each particle and clears if that particle is dead
    */
    void updateParticles(float gravity, int fps){
        for(unsigned int i=0; i<particles.size(); i++){
            bool alive = particles[i].update(gravity, fps);
            if(!alive)
                respawnParticle(i);
        }
    }

    /**
    *Renders the particles depending upon view and projection
    *If depthMask is disabled, then render the particle at last
    *Additive blending may distort the texture
    */
    void draw(glm::mat4 view, glm::mat4 projection, bool disableDepthMask = false, bool enableAdditiveBlending = false){
        if(disableDepthMask)        {GLCall(glDepthMask(GL_FALSE));}
        if(enableAdditiveBlending)  {GLCall(Window::enableAdditiveBlending());}
        else                        {GLCall(Window::enableAlphaBlending());}

        shader.bind();
        shader.addUniformMat4f("u_view", view);
        shader.addUniformMat4f("u_projection", projection);
        loadVertices(view);
        ib.bind();
        va.bind();
        texture.bind();
        GLCall(glDrawElements(GL_TRIANGLES, ib.getCount() , GL_UNSIGNED_INT, NULL));

        if(disableDepthMask){GLCall(glDepthMask(GL_TRUE));}
        GLCall(Window::disableBlending());
    }

    /**
    *Clears the buffers and shader
    */
    void cleanUP(){
        va.deleteVertexArray();
        vb.deleteVertexBuffer();
        ib.deleteIndexBuffer();
        texture.deleteTexture();
        particles.clear();
    }

    /**
    *Deletes the static shader member
    */
    static void deleteShader(){
        shader.deleteShader();
    }
};

struct CameraData{
    glm::mat4 projection;
    glm::mat4 view;
};

/**
*Logic:
*       -Render the scene from sun's perspective
*       -Store that value in depth texture
*       -Use that depth value in comparing depth with that fragment
*       -Use poisson disk distribution to adjust visibility with dark
*/
class ShadowLoader{
private:
    OpenGL::FrameBuffer fb;
    OpenGL::Texture depthTexture;
    int width, height;

    glm::vec3 lightDirection;
    glm::vec3 lightPosition;
    glm::mat4 projection;
    glm::mat4 view;

    /**
    *Calculates 8 positions of perspective position
    */
    std::vector<glm::vec3> calculateVertices(float cam_near, float cam_far, float cam_fov, float ar,
                                             glm::vec3 camPosition, glm::vec3 direction){
        std::vector<glm::vec3> vertices;
        float nearHeight = cam_near*tan(glm::radians(cam_fov/2));
        float nearWidth = nearHeight*ar;
        float farHeight = cam_far*tan(glm::radians(cam_fov/2));
        float farWidth = farHeight*ar;

        direction = glm::normalize(-direction);
        glm::vec3 right = glm::normalize(glm::cross(glm::vec3(0, 1, 0), direction));
        glm::vec3 up = glm::normalize(glm::cross(direction, right));
        glm::vec3 nearCentre = camPosition + cam_near*direction;
        glm::vec3 farCentre = camPosition + cam_far*direction;

        vertices.push_back(nearCentre + nearHeight*up + nearWidth*right);//near top right
        vertices.push_back(nearCentre + nearHeight*up - nearWidth*right);//near top left
        vertices.push_back(nearCentre - nearHeight*up + nearWidth*right);//near button right
        vertices.push_back(nearCentre - nearHeight*up - nearWidth*right);//near button left
        vertices.push_back(farCentre + farHeight*up + farWidth*right);   //far top right
        vertices.push_back(farCentre + farHeight*up - farWidth*right);   //far top left
        vertices.push_back(farCentre - farHeight*up + farWidth*right);   //far bottom right
        vertices.push_back(farCentre - farHeight*up - farWidth*right);   //far button left
        return vertices;
    }

public:
    /**
    *@param width and height is resolution of depth texture in pixels
    *@param light direction is direction of light from where shadow to be mapped
    */
    void loadData(int width, int height, int screenWidth, int screenHeight, glm::vec3 lightDirection){
        this->width = width;
        this->height = height;
        this->lightDirection = glm::normalize(lightDirection);
        fb.generateFrameBuffer(false);
        fb.bind(width, height);
        fb.AttachColorTexture(width, height);
        depthTexture.loadCreatedTexture(fb.AttachDepthTexture(width, height));
        fb.unbind(screenWidth, screenHeight);
    }

    /**
    *All drawing after sampling will have shadow
    */
    void startSampling(){
        fb.bind(width, height);
    }

    /**
    *Stops shadow sampling and draws in the screen
    */
    void stopSampling(int screenWidth, int screenHeight){
        fb.unbind(screenWidth, screenHeight);
    }

    /**
    *@param camera and other data from where screen data is rendered
    *@return the camera data from where objects to be rendered for shadow depth sampling
    *These data should be used while rendering while sampling the depth value
    */
    CameraData getCameraData(Camera camera, float cam_fov, float cam_near, float cam_far, float ar, float lightDistance,float proj_offset = 1.0){
        std::vector<glm::vec3> vertices;
        vertices = calculateVertices(cam_near, cam_far, cam_fov, ar, camera.getPosition(), camera.getDirection());
        glm::vec3 diagonal = vertices[0]-vertices[7];
        diagonal.y = 0;
        float distance = proj_offset+glm::length(diagonal);
        glm::vec3 sumPoint = glm::vec3(0.0);
        for(unsigned int i=0; i<vertices.size(); i++)
            sumPoint += vertices[i];
        sumPoint /= vertices.size();
        lightPosition = sumPoint - lightDirection;
        glm::mat4 projection = glm::ortho(-distance/2,distance/2,-distance/2,distance/2,-lightDistance/2,lightDistance/2);
        glm::mat4 view = glm::lookAt(lightPosition, sumPoint, glm::vec3(0, 1, 0));
        return {projection, view};
    }

    /**
    *Binds the depth texture at provided index
    */
    void bindDepthTexture(unsigned int i){
        depthTexture.bind(i);
    }

    void cleanUP(){
        fb.deleteBuffer();
        depthTexture.deleteTexture();
    }
};

class Renderer{

public:

    /**
    *Clears the screen with buffer color
    */
    void clear() const{
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    /**
    *@param shader to be applied
    *@param vertex array where data is saved
    *@param index buffer where index is saved
    */
    void draw(OpenGL::VertexArray& va, OpenGL::IndexBuffer& ib, OpenGL::Shader& shader) const{
        shader.bind();
        va.bind();
        ib.bind();
        GLCall(glDrawElements(GL_TRIANGLES, ib.getCount(), GL_UNSIGNED_INT, NULL))    ;
    }

    /*void draw(Mesh& mesh, OpenGL::Shader& shader){
        shader.bind();
        mesh.bindBuffers();
        GLCall(glDrawElements(GL_TRIANGLES, mesh.getIndicesCount(), GL_UNSIGNED_INT, NULL));
    }*/

    /**
    *@param obj is object file to be rendered
    *@param shader to be applied
    */
    void draw(ObjMesh& obj, OpenGL::Shader& shader){
        shader.bind();
        obj.bindArray();
        GLCall(glDrawArrays(GL_TRIANGLES, 0, obj.getVertexCount()));
    }
};

class MousePicker{
private:
    glm::vec3 currentRay;
    glm::mat4 view;
    glm::mat4 projection;

    glm::vec2 getNormalizedSpace(float x, float y, float display_width, float display_height){
        float norm_x = 2*x/display_width - 1.0;
        float norm_y = 2*y/display_height - 1.0;
        norm_y *= -1; //flipping y co-ordinate because co-ordinate starts from top left corner
        return glm::vec2(norm_x, norm_y);
    }

    glm::vec4 clipToEyeSpace(glm::vec4 clipSpace){
        glm::mat4 projection_inverse = glm::inverse(projection);
        glm::vec4 eyeCords = projection_inverse * clipSpace;
        return glm::vec4(eyeCords.x, eyeCords.y, -1.0f, 0.0f);
    }

    glm::vec3 eyeToWorld(glm::vec4 eyeSpace){
        glm::mat4 view_inverse = glm::inverse(view);
        glm::vec4 worldCords = view_inverse * eyeSpace;
        glm::vec3 result = glm::vec3(worldCords.x, worldCords.y, worldCords.z);
        result = glm::normalize(result);
        return result;
    }
public:
    void setMatrices(glm::mat4 view, glm::mat4 projection){
        this->view = view;
        this->projection = projection;
    }

    glm::vec3 getRay(){
        return currentRay;
    }

    /**
    *Using normalized space
    */
    glm::vec3 calculateRay(float x,float y){
        glm::vec4 clipCords = glm::vec4( x, y, -1.0f, 1.0f);
        glm::vec4 eyeSpace = clipToEyeSpace(clipCords);
        glm::vec3 worldSpace = eyeToWorld(eyeSpace);
        return worldSpace;
    }

    /**
    *Using screen co-ordinate space
    */
    glm::vec3 calculateRay(float x,float y, float width, float height)
    {
        glm::vec2 normalized = getNormalizedSpace(x, y, width, height);
        return calculateRay(normalized.x, normalized.y);
    }

};

class Mesh {
private:
    OpenGL::VertexArray va;
    OpenGL::VertexBuffer vb;
    OpenGL::IndexBuffer ib;

public:
    void loadMesh(std::vector<SimpleVertex> vertices, std::vector<unsigned int> indices/*, std::vector<s_Texture> textures*/){
        va.generateVertexArray();
        vb.loadData(&vertices[0], vertices.size()*sizeof(SimpleVertex));
        ib.loadData(&indices[0], indices.size());
        OpenGL::VertexBufferLayout vbl;
        vbl.pushFloat(3);
        vbl.pushFloat(3);
        vbl.pushFloat(2);
        va.addBuffer(vb, vbl);
    }

    void bindBuffers(){
        va.bind();
        ib.bind();
    }

    unsigned int getIndicesCount(){
        return ib.getCount();
    }

    void deleteBuffers(){
        va.deleteVertexArray();
        vb.deleteVertexBuffer();
        ib.deleteIndexBuffer();
    }
};
